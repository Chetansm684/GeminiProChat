// src/merge-props.ts
import { mergeProps as solidMergeProps } from "solid-js";

// src/prop-trap.ts
import { $PROXY } from "solid-js";
function trueFn() {
  return true;
}
var propTraps = {
  get(_, property, receiver) {
    if (property === $PROXY)
      return receiver;
    return _.get(property);
  },
  has(_, property) {
    return _.has(property);
  },
  set: trueFn,
  deleteProperty: trueFn,
  getOwnPropertyDescriptor(_, property) {
    return {
      configurable: true,
      enumerable: true,
      get() {
        return _.get(property);
      },
      set: trueFn,
      deleteProperty: trueFn
    };
  },
  ownKeys(_) {
    return _.keys();
  }
};

// src/merge-props.ts
var access = (v) => typeof v === "function" && !v.length ? v() : v;
function chain(fns) {
  return (...args) => {
    for (const fn of fns) {
      fn && fn(...args);
    }
  };
}
var cssRegex = /((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g;
function stringStyleToObject(style) {
  const object = {};
  let match;
  while (match = cssRegex.exec(style)) {
    object[match[1]] = match[2];
  }
  return object;
}
function mergeStyle(a, b) {
  if (typeof a === "object" && typeof b === "object")
    return { ...a, ...b };
  if (typeof a === "string" && typeof b === "string")
    return `${a};${b}`;
  const objA = typeof a === "object" ? a : stringStyleToObject(a);
  const objB = typeof b === "object" ? b : stringStyleToObject(b);
  return { ...objA, ...objB };
}
var reduce = (sources, key, calc) => {
  let v = void 0;
  for (const props of sources) {
    const propV = access(props)[key];
    if (!v)
      v = propV;
    else if (propV)
      v = calc(v, propV);
  }
  return v;
};
function mergeProps(...sources) {
  if (sources.length === 1) {
    return sources[0];
  }
  const listeners = {};
  for (const props of sources) {
    const properties = access(props);
    for (const key in properties) {
      if (key[0] === "o" && key[1] === "n" && key[2]) {
        const value = properties[key];
        const name = key.toLowerCase();
        const callback = typeof value === "function" ? value : (
          // jsx event handlers can be tuples of [callback, arg]
          Array.isArray(value) ? value.length === 1 ? value[0] : value[0].bind(void 0, value[1]) : void 0
        );
        if (callback)
          listeners[name] ? listeners[name].push(callback) : listeners[name] = [callback];
        else
          delete listeners[name];
      }
    }
  }
  const merge = solidMergeProps(...sources);
  return new Proxy(
    {
      get(key) {
        if (typeof key !== "string") {
          return Reflect.get(merge, key);
        }
        if (key === "style") {
          return reduce(sources, "style", mergeStyle);
        }
        if (key === "ref") {
          const fns = [];
          for (const props of sources) {
            const fn = access(props)[key];
            if (typeof fn === "function") {
              fns.push(fn);
            }
          }
          return chain(fns);
        }
        if (key[0] === "o" && key[1] === "n" && key[2]) {
          const fns = listeners[key.toLowerCase()];
          return fns ? chain(fns) : Reflect.get(merge, key);
        }
        if (key === "class" || key === "className") {
          return reduce(sources, key, (a, b) => `${a} ${b}`);
        }
        if (key === "classList") {
          return reduce(sources, key, (a, b) => ({ ...a, ...b }));
        }
        return Reflect.get(merge, key);
      },
      has(key) {
        return Reflect.has(merge, key);
      },
      keys() {
        return Object.keys(merge);
      }
    },
    propTraps
  );
}

// src/normalize-props.ts
import { createNormalizer } from "@zag-js/types";

// ../../utilities/core/src/guard.ts
var isArray = (v) => Array.isArray(v);
var isObject = (v) => !(v == null || typeof v !== "object" || isArray(v));
var isNumber = (v) => typeof v === "number" && !Number.isNaN(v);
var isString = (v) => typeof v === "string";

// src/cssify.ts
import hyphenate from "hyphenate-style-name";
var format = (v) => v.startsWith("--") ? v : hyphenate(v);
function cssify(style) {
  let css = {};
  for (const property in style) {
    const value = style[property];
    if (!isString(value) && !isNumber(value))
      continue;
    css[format(property)] = value;
  }
  return css;
}

// src/normalize-props.ts
var eventMap = {
  onFocus: "onFocusIn",
  onBlur: "onFocusOut",
  onDoubleClick: "onDblClick",
  onChange: "onInput",
  defaultChecked: "checked",
  defaultValue: "value",
  htmlFor: "for",
  className: "class"
};
function toSolidProp(prop) {
  return prop in eventMap ? eventMap[prop] : prop;
}
var normalizeProps = createNormalizer((props) => {
  const normalized = {};
  for (const key in props) {
    const value = props[key];
    if (key === "style" && isObject(value)) {
      normalized["style"] = cssify(value);
      continue;
    }
    if (key === "children") {
      if (isString(value)) {
        normalized["textContent"] = value;
      }
      continue;
    }
    normalized[toSolidProp(key)] = value;
  }
  return normalized;
});

// src/use-actor.ts
import { onCleanup, onMount } from "solid-js";
import { createStore, reconcile } from "solid-js/store";
function useActor(service) {
  const [state, setState] = createStore(service.getState());
  onMount(() => {
    const unsubscribe = service.subscribe((nextState) => {
      setState(reconcile(nextState));
    });
    onCleanup(() => {
      unsubscribe();
    });
  });
  return [state, service.send];
}

// src/use-machine.ts
import { createEffect, onCleanup as onCleanup2, onMount as onMount2 } from "solid-js";
import { createStore as createStore2, reconcile as reconcile2 } from "solid-js/store";
function useService(machine, options) {
  const { actions, state: hydratedState, context } = options ?? {};
  const service = (() => {
    const _machine = typeof machine === "function" ? machine() : machine;
    const contextValue = typeof context === "function" ? context() : context;
    return contextValue ? _machine.withContext(contextValue) : _machine;
  })();
  onMount2(() => {
    service.start(hydratedState);
    if (service.state.can("SETUP")) {
      service.send("SETUP");
    }
    onCleanup2(() => {
      service.stop();
    });
  });
  createEffect(() => {
    const contextValue = typeof context === "function" ? context() : context;
    service.setContext(contextValue);
  });
  createEffect(() => {
    service.setOptions({ actions });
  });
  return service;
}
function useMachine(machine, options) {
  const service = useService(machine, options);
  const [state, setState] = createStore2(service.getState());
  onMount2(() => {
    const unsubscribe = service.subscribe((nextState) => {
      setState(reconcile2(nextState));
    });
    onCleanup2(() => {
      unsubscribe();
    });
  });
  return [state, service.send, service];
}
export {
  mergeProps,
  normalizeProps,
  propTraps,
  useActor,
  useMachine,
  useService
};
//# sourceMappingURL=index.mjs.map