import "./chunk-CF3WPAMV.js";

// node_modules/.pnpm/@zag-js+anatomy@0.16.0/node_modules/@zag-js/anatomy/dist/index.mjs
var createAnatomy = (name, parts2 = []) => ({
  parts: (...values) => {
    if (isEmpty(parts2)) {
      return createAnatomy(name, values);
    }
    throw new Error("createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?");
  },
  extendWith: (...values) => createAnatomy(name, [...parts2, ...values]),
  rename: (newName) => createAnatomy(newName, parts2),
  keys: () => parts2,
  build: () => [...new Set(parts2)].reduce(
    (prev, part) => Object.assign(prev, {
      [part]: {
        selector: [
          `&[data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`,
          `& [data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`
        ].join(", "),
        attrs: { "data-scope": toKebabCase(name), "data-part": toKebabCase(part) }
      }
    }),
    {}
  )
});
var toKebabCase = (value) => value.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
var isEmpty = (v) => v.length === 0;

// node_modules/.pnpm/@zag-js+dom-query@0.16.0/node_modules/@zag-js/dom-query/dist/index.mjs
var dataAttr = (guard) => {
  return guard ? "" : void 0;
};
var ariaAttr = (guard) => {
  return guard ? "true" : void 0;
};
var getDocument = (node) => {
  if (node.nodeType === Node.DOCUMENT_NODE)
    return node;
  return node.ownerDocument ?? document;
};
function createScope(methods) {
  const screen = {
    getRootNode: (ctx) => {
      var _a;
      return ((_a = ctx.getRootNode) == null ? void 0 : _a.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument(screen.getRootNode(ctx)),
    getWin: (ctx) => screen.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => screen.getDoc(ctx).activeElement,
    getById: (ctx, id) => screen.getRootNode(ctx).getElementById(id)
  };
  return { ...screen, ...methods };
}
function itemById(v, id) {
  return v.find((node) => node.id === id);
}
function indexOfId(v, id) {
  const item = itemById(v, id);
  return item ? v.indexOf(item) : -1;
}
var getValueText = (item) => item.dataset.valuetext ?? item.textContent ?? "";
var match = (valueText, query2) => valueText.toLowerCase().startsWith(query2.toLowerCase());
var wrap = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText(v, text, currentId) {
  const index = currentId ? indexOfId(v, currentId) : -1;
  let items = currentId ? wrap(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => item.id !== currentId);
  }
  return items.find((item) => match(getValueText(item), text));
}
function getByTypeaheadImpl(_items, options) {
  const { state: state2, activeId, key, timeout = 350 } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const query2 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next = getByText(items, query2, activeId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next;
}
var getByTypeahead = Object.assign(getByTypeaheadImpl, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent
});
function isValidTypeaheadEvent(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
var isDom = () => typeof document !== "undefined";
function getPlatform() {
  const agent = navigator.userAgentData;
  return (agent == null ? void 0 : agent.platform) ?? navigator.platform;
}
var pt = (v) => isDom() && v.test(getPlatform());
var isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;
var isMac = () => pt(/^Mac/) && !isTouchDevice();
var isApple = () => pt(/mac|iphone|ipad|ipod/i);
var isIos = () => isApple() && !isMac();
function nextTick(fn) {
  const set2 = /* @__PURE__ */ new Set();
  function raf2(fn2) {
    const id = globalThis.requestAnimationFrame(fn2);
    set2.add(() => globalThis.cancelAnimationFrame(id));
  }
  raf2(() => raf2(fn));
  return function cleanup() {
    set2.forEach((fn2) => fn2());
  };
}
function raf(fn) {
  const id = globalThis.requestAnimationFrame(fn);
  return () => {
    globalThis.cancelAnimationFrame(id);
  };
}

// node_modules/.pnpm/@zag-js+text-selection@0.16.0/node_modules/@zag-js/text-selection/dist/index.mjs
var state = "default";
var userSelect = "";
var elementMap = /* @__PURE__ */ new WeakMap();
function disableTextSelectionImpl(options = {}) {
  const { target, doc } = options;
  const docNode = doc ?? document;
  const rootEl = docNode.documentElement;
  if (isIos()) {
    if (state === "default") {
      userSelect = rootEl.style.webkitUserSelect;
      rootEl.style.webkitUserSelect = "none";
    }
    state = "disabled";
  } else if (target) {
    elementMap.set(target, target.style.userSelect);
    target.style.userSelect = "none";
  }
  return () => restoreTextSelection({ target, doc: docNode });
}
function restoreTextSelection(options = {}) {
  const { target, doc } = options;
  const docNode = doc ?? document;
  const rootEl = docNode.documentElement;
  if (isIos()) {
    if (state !== "disabled")
      return;
    state = "restoring";
    setTimeout(() => {
      nextTick(() => {
        if (state === "restoring") {
          if (rootEl.style.webkitUserSelect === "none") {
            rootEl.style.webkitUserSelect = userSelect || "";
          }
          userSelect = "";
          state = "default";
        }
      });
    }, 300);
  } else {
    if (target && elementMap.has(target)) {
      const prevUserSelect = elementMap.get(target);
      if (target.style.userSelect === "none") {
        target.style.userSelect = prevUserSelect ?? "";
      }
      if (target.getAttribute("style") === "") {
        target.removeAttribute("style");
      }
      elementMap.delete(target);
    }
  }
}
function disableTextSelection(options = {}) {
  const { defer, target, ...restOptions } = options;
  const func = defer ? raf : (v) => v();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node = typeof target === "function" ? target() : target;
      cleanups.push(disableTextSelectionImpl({ ...restOptions, target: node }));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn == null ? void 0 : fn());
  };
}

// node_modules/.pnpm/@zag-js+dom-event@0.16.0/node_modules/@zag-js/dom-event/dist/index.mjs
var addDomEvent = (target, eventName, handler, options) => {
  const node = typeof target === "function" ? target() : target;
  node == null ? void 0 : node.addEventListener(eventName, handler, options);
  return () => {
    node == null ? void 0 : node.removeEventListener(eventName, handler, options);
  };
};
var isLeftClick = (e2) => e2.button === 0;
var isModifiedEvent = (e2) => e2.ctrlKey || e2.altKey || e2.metaKey;
var keyMap = {
  Up: "ArrowUp",
  Down: "ArrowDown",
  Esc: "Escape",
  " ": "Space",
  ",": "Comma",
  Left: "ArrowLeft",
  Right: "ArrowRight"
};
var rtlKeyMap = {
  ArrowLeft: "ArrowRight",
  ArrowRight: "ArrowLeft"
};
function getEventKey(event, options = {}) {
  const { dir = "ltr", orientation = "horizontal" } = options;
  let { key } = event;
  key = keyMap[key] ?? key;
  const isRtl = dir === "rtl" && orientation === "horizontal";
  if (isRtl && key in rtlKeyMap) {
    key = rtlKeyMap[key];
  }
  return key;
}
function pointFromTouch(e2, type = "client") {
  const point = e2.touches[0] || e2.changedTouches[0];
  return { x: point[`${type}X`], y: point[`${type}Y`] };
}
function pointFromMouse(point, type = "client") {
  return { x: point[`${type}X`], y: point[`${type}Y`] };
}
var isTouchEvent = (event) => "touches" in event && event.touches.length > 0;
function getEventPoint(event, type = "client") {
  return isTouchEvent(event) ? pointFromTouch(event, type) : pointFromMouse(event, type);
}
var PAGE_KEYS = /* @__PURE__ */ new Set(["PageUp", "PageDown"]);
var ARROW_KEYS = /* @__PURE__ */ new Set(["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"]);
function getEventStep(event) {
  if (event.ctrlKey || event.metaKey) {
    return 0.1;
  } else {
    const isPageKey = PAGE_KEYS.has(event.key);
    const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.has(event.key);
    return isSkipKey ? 10 : 1;
  }
}
function getNativeEvent(event) {
  return event.nativeEvent ?? event;
}
function clamp(value) {
  return Math.max(0, Math.min(1, value));
}
function getRelativePoint(point, element) {
  const { left, top, width, height } = element.getBoundingClientRect();
  const offset = { x: point.x - left, y: point.y - top };
  const percent = { x: clamp(offset.x / width), y: clamp(offset.y / height) };
  function getPercentValue2(options = {}) {
    const { dir = "ltr", orientation = "horizontal", inverted } = options;
    const invertX = typeof inverted === "object" ? inverted.x : inverted;
    const invertY = typeof inverted === "object" ? inverted.y : inverted;
    if (orientation === "horizontal") {
      return dir === "rtl" || invertX ? 1 - percent.x : percent.x;
    }
    return invertY ? 1 - percent.y : percent.y;
  }
  return { offset, percent, getPercentValue: getPercentValue2 };
}
function trackPointerMove(doc, handlers) {
  const { onPointerMove, onPointerUp } = handlers;
  const handleMove = (event) => {
    const point = getEventPoint(event);
    const distance = Math.sqrt(point.x ** 2 + point.y ** 2);
    const moveBuffer = event.pointerType === "touch" ? 10 : 5;
    if (distance < moveBuffer)
      return;
    if (event.pointerType === "mouse" && event.button === 0) {
      onPointerUp();
      return;
    }
    onPointerMove({ point, event });
  };
  const cleanups = [
    addDomEvent(doc, "pointermove", handleMove, false),
    addDomEvent(doc, "pointerup", onPointerUp, false),
    addDomEvent(doc, "pointercancel", onPointerUp, false),
    addDomEvent(doc, "contextmenu", onPointerUp, false),
    disableTextSelection({ doc })
  ];
  return () => {
    cleanups.forEach((cleanup) => cleanup());
  };
}

// node_modules/.pnpm/@zag-js+numeric-range@0.16.0/node_modules/@zag-js/numeric-range/dist/index.mjs
function getMinValueAtIndex(index, values, minValue) {
  return index === 0 ? minValue : values[index - 1];
}
function getMaxValueAtIndex(index, values, maxValue) {
  return index === values.length - 1 ? maxValue : values[index + 1];
}
function getRoundedValue(value, minValue, step) {
  return Math.round((value - minValue) / step) * step + minValue;
}
function clampValue(value, minValue, maxValue) {
  return Math.min(Math.max(value, minValue), maxValue);
}
function getValuePercent(value, minValue, maxValue) {
  return (value - minValue) / (maxValue - minValue);
}
function getPercentValue(percent, minValue, maxValue, step) {
  const value = percent * (maxValue - minValue) + minValue;
  const roundedValue = getRoundedValue(value, minValue, step);
  return clampValue(roundedValue, minValue, maxValue);
}
function snapValueToStep(value, min, max, step) {
  let remainder = (value - (isNaN(min) ? 0 : min)) % step;
  let snappedValue = Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder;
  if (!isNaN(min)) {
    if (snappedValue < min) {
      snappedValue = min;
    } else if (!isNaN(max) && snappedValue > max) {
      snappedValue = min + Math.floor((max - min) / step) * step;
    }
  } else if (!isNaN(max) && snappedValue > max) {
    snappedValue = Math.floor(max / step) * step;
  }
  let string = step.toString();
  let index = string.indexOf(".");
  let precision = index >= 0 ? string.length - index : 0;
  if (precision > 0) {
    let pow = Math.pow(10, precision);
    snappedValue = Math.round(snappedValue * pow) / pow;
  }
  return snappedValue;
}
function setValueAtIndex(values, index, value) {
  if (values[index] === value)
    return values;
  return [...values.slice(0, index), value, ...values.slice(index + 1)];
}
function getValueSetterAtIndex(index, ctx) {
  const minValueAtIndex = getMinValueAtIndex(index, ctx.values, ctx.min);
  const maxValueAtIndex = getMaxValueAtIndex(index, ctx.values, ctx.max);
  let nextValues = ctx.values.slice();
  return function setValue(value) {
    let nextValue = snapValueToStep(value, minValueAtIndex, maxValueAtIndex, ctx.step);
    nextValues = setValueAtIndex(nextValues, index, value);
    nextValues[index] = nextValue;
    return nextValues;
  };
}
function getNextStepValue(index, ctx) {
  const nextValue = ctx.values[index] + ctx.step;
  return getValueSetterAtIndex(index, ctx)(nextValue);
}
function getPreviousStepValue(index, ctx) {
  const nextValue = ctx.values[index] - ctx.step;
  return getValueSetterAtIndex(index, ctx)(nextValue);
}
function getValueTransformer(valueA, valueB) {
  const input = { min: valueA[0], max: valueA[1] };
  const output = { min: valueB[0], max: valueB[1] };
  return function getValue(value) {
    if (input.min === input.max || output.min === output.max)
      return output.min;
    const ratio = (output.max - output.min) / (input.max - input.min);
    return output.min + ratio * (value - input.min);
  };
}

// node_modules/.pnpm/@zag-js+mutation-observer@0.16.0/node_modules/@zag-js/mutation-observer/dist/index.mjs
function observeAttributes(node, attributes, fn) {
  if (!node)
    return;
  const win = node.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver((changes) => {
    for (const change of changes) {
      if (change.type === "attributes" && change.attributeName && attributes.includes(change.attributeName)) {
        fn(change);
      }
    }
  });
  obs.observe(node, { attributes: true, attributeFilter: attributes });
  return () => obs.disconnect();
}

// node_modules/.pnpm/@zag-js+form-utils@0.16.0/node_modules/@zag-js/form-utils/dist/index.mjs
var getWindow = (el) => el.ownerDocument.defaultView || window;
function getDescriptor(el, options) {
  const { type, property = "value" } = options;
  const proto = getWindow(el)[type].prototype;
  return Object.getOwnPropertyDescriptor(proto, property) ?? {};
}
function dispatchInputValueEvent(el, options) {
  var _a;
  if (!el)
    return;
  const win = getWindow(el);
  if (!(el instanceof win.HTMLInputElement))
    return;
  const { value, bubbles = true } = options;
  const descriptor = getDescriptor(el, {
    type: "HTMLInputElement",
    property: "value"
  });
  (_a = descriptor.set) == null ? void 0 : _a.call(el, value);
  const event = new win.Event("input", { bubbles });
  el.dispatchEvent(event);
}
function getClosestForm(el) {
  if (isFormElement(el))
    return el.form;
  else
    return el.closest("form");
}
function isFormElement(el) {
  return el.matches("textarea, input, select, button");
}
function trackFormReset(el, callback) {
  if (!el)
    return;
  const form = getClosestForm(el);
  form == null ? void 0 : form.addEventListener("reset", callback, { passive: true });
  return () => {
    form == null ? void 0 : form.removeEventListener("reset", callback);
  };
}
function trackFieldsetDisabled(el, callback) {
  const fieldset = el == null ? void 0 : el.closest("fieldset");
  if (!fieldset)
    return;
  callback(fieldset.disabled);
  return observeAttributes(fieldset, ["disabled"], () => callback(fieldset.disabled));
}
function trackFormControl(el, options) {
  if (!el)
    return;
  const { onFieldsetDisabled, onFormReset } = options;
  const cleanups = [
    trackFormReset(el, onFormReset),
    trackFieldsetDisabled(el, (disabled) => {
      if (disabled)
        onFieldsetDisabled();
    })
  ];
  return () => {
    cleanups.forEach((cleanup) => cleanup == null ? void 0 : cleanup());
  };
}

// node_modules/.pnpm/proxy-compare@2.5.1/node_modules/proxy-compare/dist/index.modern.js
var e = Symbol();
var t = Symbol();
var s = Object.getPrototypeOf;
var c = /* @__PURE__ */ new WeakMap();
var l = (e2) => e2 && (c.has(e2) ? c.get(e2) : s(e2) === Object.prototype || s(e2) === Array.prototype);
var y = (e2) => l(e2) && e2[t] || null;
var h = (e2, t2 = true) => {
  c.set(e2, t2);
};

// node_modules/.pnpm/@zag-js+store@0.16.0/node_modules/@zag-js/store/dist/index.mjs
var isDev = true;
var isObject = (x) => typeof x === "object" && x !== null;
var proxyStateMap = /* @__PURE__ */ new WeakMap();
var refSet = /* @__PURE__ */ new WeakSet();
var buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache = snapCache.get(target);
  if ((cache == null ? void 0 : cache[0]) === version) {
    return cache[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  h(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet.has(value)) {
      h(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap.has(value)) {
      snap[key] = snapshot(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction2 = (initialObject) => {
  if (!isObject(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a = entry[1]) == null ? void 0 : _a.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove], prop) => {
          if (remove) {
            remove();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject(value)) {
        value = y(value) || value;
      }
      let nextValue = value;
      if ((_a = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          value.status = "fulfilled";
          value.value = v;
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e2) => {
          value.status = "rejected";
          value.reason = e2;
          notifyUpdate(["reject", [prop], e2]);
        });
      } else {
        if (!proxyStateMap.has(value) && canProxy(value)) {
          nextValue = proxy(value);
        }
        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction2,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  objectIs,
  newProxy,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return proxyFunction(initialObject);
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (isDev && !proxyState) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const addListener = proxyState[3];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener = addListener(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener();
  };
}
function snapshot(proxyObject, handlePromise) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (isDev && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}
function ref(obj) {
  refSet.add(obj);
  return obj;
}
function proxyWithComputed(initialObject, computedFns) {
  const keys = Object.keys(computedFns);
  keys.forEach((key) => {
    if (Object.getOwnPropertyDescriptor(initialObject, key)) {
      throw new Error("object property already defined");
    }
    const computedFn = computedFns[key];
    const { get, set: set2 } = typeof computedFn === "function" ? { get: computedFn } : computedFn;
    const desc = {};
    desc.get = () => get(snapshot(proxyObject));
    if (set2) {
      desc.set = (newValue) => set2(proxyObject, newValue);
    }
    Object.defineProperty(initialObject, key, desc);
  });
  const proxyObject = proxy(initialObject);
  return proxyObject;
}
var defaultCompareFn = (prev, next) => Object.is(prev, next);
function subscribeKey(obj, key, fn, sync, compareFn) {
  let prev = Reflect.get(snapshot(obj), key);
  const isEqual = compareFn || defaultCompareFn;
  function onSnapshotChange() {
    const snap = snapshot(obj);
    if (isEqual(prev, snap[key]))
      return;
    fn(snap[key]);
    prev = Reflect.get(snap, key);
  }
  return subscribe(obj, onSnapshotChange, sync);
}

// node_modules/.pnpm/klona@2.0.6/node_modules/klona/full/index.mjs
function set(obj, key, val) {
  if (typeof val.value === "object")
    val.value = klona(val.value);
  if (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === "__proto__") {
    Object.defineProperty(obj, key, val);
  } else
    obj[key] = val.value;
}
function klona(x) {
  if (typeof x !== "object")
    return x;
  var i = 0, k, list, tmp, str = Object.prototype.toString.call(x);
  if (str === "[object Object]") {
    tmp = Object.create(x.__proto__ || null);
  } else if (str === "[object Array]") {
    tmp = Array(x.length);
  } else if (str === "[object Set]") {
    tmp = /* @__PURE__ */ new Set();
    x.forEach(function(val) {
      tmp.add(klona(val));
    });
  } else if (str === "[object Map]") {
    tmp = /* @__PURE__ */ new Map();
    x.forEach(function(val, key) {
      tmp.set(klona(key), klona(val));
    });
  } else if (str === "[object Date]") {
    tmp = /* @__PURE__ */ new Date(+x);
  } else if (str === "[object RegExp]") {
    tmp = new RegExp(x.source, x.flags);
  } else if (str === "[object DataView]") {
    tmp = new x.constructor(klona(x.buffer));
  } else if (str === "[object ArrayBuffer]") {
    tmp = x.slice(0);
  } else if (str.slice(-6) === "Array]") {
    tmp = new x.constructor(x);
  }
  if (tmp) {
    for (list = Object.getOwnPropertySymbols(x); i < list.length; i++) {
      set(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));
    }
    for (i = 0, list = Object.getOwnPropertyNames(x); i < list.length; i++) {
      if (Object.hasOwnProperty.call(tmp, k = list[i]) && tmp[k] === x[k])
        continue;
      set(tmp, k, Object.getOwnPropertyDescriptor(x, k));
    }
  }
  return tmp || x;
}

// node_modules/.pnpm/@zag-js+core@0.16.0/node_modules/@zag-js/core/dist/index.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function clear(v) {
  while (v.length > 0)
    v.pop();
  return v;
}
var runIfFn = (v, ...a) => {
  const res = typeof v === "function" ? v(...a) : v;
  return res ?? void 0;
};
var cast = (v) => v;
var noop = () => {
};
var uuid = (() => {
  let id = 0;
  return () => {
    id++;
    return id.toString(36);
  };
})();
var isDev2 = () => true;
var isArray = (v) => Array.isArray(v);
var isObject2 = (v) => !(v == null || typeof v !== "object" || isArray(v));
var isNumber = (v) => typeof v === "number" && !Number.isNaN(v);
var isString = (v) => typeof v === "string";
var isFunction = (v) => typeof v === "function";
function compact(obj) {
  if (!isPlainObject(obj) || obj === void 0) {
    return obj;
  }
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact(value);
    }
  }
  return filtered;
}
var isPlainObject = (value) => {
  return value && typeof value === "object" && value.constructor === Object;
};
function warn(...a) {
  const m = a.length === 1 ? a[0] : a[1];
  const c2 = a.length === 2 ? a[0] : true;
  if (c2 && true) {
    console.warn(m);
  }
}
function invariant(...a) {
  const m = a.length === 1 ? a[0] : a[1];
  const c2 = a.length === 2 ? a[0] : true;
  if (c2 && true) {
    throw new Error(m);
  }
}
function deepMerge(source, ...objects) {
  for (const obj of objects) {
    const target = compact(obj);
    for (const key in target) {
      if (isObject2(obj[key])) {
        if (!source[key]) {
          source[key] = {};
        }
        deepMerge(source[key], obj[key]);
      } else {
        source[key] = obj[key];
      }
    }
  }
  return source;
}
function structuredClone(v) {
  return klona(v);
}
function toEvent(event) {
  const obj = isString(event) ? { type: event } : event;
  return obj;
}
function toArray(value) {
  if (!value)
    return [];
  return isArray(value) ? value.slice() : [value];
}
function isGuardHelper(value) {
  return isObject2(value) && value.predicate != null;
}
var Truthy = () => true;
function determineGuardFn(guard, guardMap) {
  guard = guard ?? Truthy;
  return (context, event, meta) => {
    if (isString(guard)) {
      const value = guardMap[guard];
      return isFunction(value) ? value(context, event, meta) : value;
    }
    if (isGuardHelper(guard)) {
      return guard.predicate(guardMap)(context, event, meta);
    }
    return guard == null ? void 0 : guard(context, event, meta);
  };
}
function determineActionsFn(values, guardMap) {
  return (context, event, meta) => {
    if (isGuardHelper(values)) {
      return values.predicate(guardMap)(context, event, meta);
    }
    return values;
  };
}
function createProxy(config) {
  const computedContext = config.computed ?? cast({});
  const initialContext = config.context ?? cast({});
  const state2 = proxy({
    value: config.initial ?? "",
    previousValue: "",
    event: cast({}),
    previousEvent: cast({}),
    context: proxyWithComputed(initialContext, computedContext),
    done: false,
    tags: [],
    hasTag(tag) {
      return this.tags.includes(tag);
    },
    matches(...value) {
      return value.includes(this.value);
    },
    can(event) {
      return cast(this).nextEvents.includes(event);
    },
    get nextEvents() {
      var _a, _b;
      const stateEvents = ((_b = (_a = config.states) == null ? void 0 : _a[this.value]) == null ? void 0 : _b["on"]) ?? {};
      const globalEvents = (config == null ? void 0 : config.on) ?? {};
      return Object.keys({ ...stateEvents, ...globalEvents });
    },
    get changed() {
      if (this.event.value === "machine.init" || !this.previousValue)
        return false;
      return this.value !== this.previousValue;
    }
  });
  return cast(state2);
}
function determineDelayFn(delay, delaysMap) {
  return (context, event) => {
    if (isNumber(delay))
      return delay;
    if (isFunction(delay)) {
      return delay(context, event);
    }
    if (isString(delay)) {
      const value = Number.parseFloat(delay);
      if (!Number.isNaN(value)) {
        return value;
      }
      if (delaysMap) {
        const valueOrFn = delaysMap == null ? void 0 : delaysMap[delay];
        invariant(
          valueOrFn == null,
          `[@zag-js/core > determine-delay] Cannot determine delay for \`${delay}\`. It doesn't exist in \`options.delays\``
        );
        return isFunction(valueOrFn) ? valueOrFn(context, event) : valueOrFn;
      }
    }
  };
}
function toTarget(target) {
  return isString(target) ? { target } : target;
}
function determineTransitionFn(transitions, guardMap) {
  return (context, event, meta) => {
    return toArray(transitions).map(toTarget).find((transition) => {
      const determineGuard = determineGuardFn(transition.guard, guardMap);
      const guard = determineGuard(context, event, meta);
      return guard ?? transition.target ?? transition.actions;
    });
  };
}
var Machine = class _Machine {
  // Let's get started!
  constructor(config, options) {
    var _a, _b, _c, _d, _e, _f;
    __publicField(
      this,
      "status",
      "Not Started"
      /* NotStarted */
    );
    __publicField(this, "state");
    __publicField(this, "initialState");
    __publicField(this, "initialContext");
    __publicField(this, "id");
    __publicField(
      this,
      "type",
      "machine"
      /* Machine */
    );
    __publicField(this, "activityEvents", /* @__PURE__ */ new Map());
    __publicField(this, "delayedEvents", /* @__PURE__ */ new Map());
    __publicField(this, "stateListeners", /* @__PURE__ */ new Set());
    __publicField(this, "contextListeners", /* @__PURE__ */ new Set());
    __publicField(this, "eventListeners", /* @__PURE__ */ new Set());
    __publicField(this, "doneListeners", /* @__PURE__ */ new Set());
    __publicField(this, "contextWatchers", /* @__PURE__ */ new Set());
    __publicField(this, "removeStateListener", noop);
    __publicField(this, "removeEventListener", noop);
    __publicField(this, "removeContextListener", noop);
    __publicField(this, "parent");
    __publicField(this, "children", /* @__PURE__ */ new Map());
    __publicField(this, "guardMap");
    __publicField(this, "actionMap");
    __publicField(this, "delayMap");
    __publicField(this, "activityMap");
    __publicField(this, "sync");
    __publicField(this, "options");
    __publicField(this, "config");
    __publicField(this, "start", (init) => {
      this.state.value = "";
      if (this.status === "Running") {
        return this;
      }
      this.status = "Running";
      this.removeStateListener = subscribe(
        this.state,
        () => {
          this.stateListeners.forEach((listener) => {
            listener(this.stateSnapshot);
          });
        },
        this.sync
      );
      this.removeEventListener = subscribeKey(
        this.state,
        "event",
        (event22) => {
          this.executeActions(this.config.onEvent, event22);
          this.eventListeners.forEach((listener) => {
            listener(event22);
          });
        },
        this.sync
      );
      this.removeContextListener = subscribe(
        this.state.context,
        () => {
          this.log("Context:", this.contextSnapshot);
          this.contextListeners.forEach((listener) => {
            listener(this.contextSnapshot);
          });
        },
        this.sync || this.options.debug
      );
      this.setupContextWatchers();
      this.executeActivities(
        toEvent(
          "machine.start"
          /* Start */
        ),
        toArray(this.config.activities),
        "machine.start"
        /* Start */
      );
      this.executeActions(this.config.entry, toEvent(
        "machine.start"
        /* Start */
      ));
      const event2 = toEvent(
        "machine.init"
        /* Init */
      );
      const target = isObject2(init) ? init.value : init;
      const context = isObject2(init) ? init.context : void 0;
      if (context) {
        this.setContext(context);
      }
      const transition = {
        target: target ?? this.config.initial
      };
      const next = this.getNextStateInfo(transition, event2);
      this.initialState = next;
      this.performStateChangeEffects(this.state.value, next, event2);
      return this;
    });
    __publicField(this, "setupContextWatchers", () => {
      var _a2;
      for (const [key, fn] of Object.entries(this.config.watch ?? {})) {
        const compareFn = (_a2 = this.options.compareFns) == null ? void 0 : _a2[key];
        const cleanup = subscribeKey(
          this.state.context,
          key,
          () => {
            this.executeActions(fn, this.state.event);
          },
          this.sync,
          compareFn
        );
        this.contextWatchers.add(cleanup);
      }
    });
    __publicField(this, "stop", () => {
      if (this.status === "Stopped")
        return;
      this.performExitEffects(this.state.value, toEvent(
        "machine.stop"
        /* Stop */
      ));
      this.executeActions(this.config.exit, toEvent(
        "machine.stop"
        /* Stop */
      ));
      this.setState("");
      this.setEvent(
        "machine.stop"
        /* Stop */
      );
      this.stopStateListeners();
      this.stopChildren();
      this.stopActivities();
      this.stopDelayedEvents();
      this.stopContextWatchers();
      this.stopEventListeners();
      this.stopContextListeners();
      this.status = "Stopped";
      return this;
    });
    __publicField(this, "stopEventListeners", () => {
      this.eventListeners.clear();
      this.removeEventListener();
    });
    __publicField(this, "stopContextListeners", () => {
      this.contextListeners.clear();
      this.removeContextListener();
    });
    __publicField(this, "stopStateListeners", () => {
      this.removeStateListener();
      this.stateListeners.clear();
    });
    __publicField(this, "stopContextWatchers", () => {
      this.contextWatchers.forEach((fn) => fn());
      this.contextWatchers.clear();
    });
    __publicField(this, "stopDelayedEvents", () => {
      this.delayedEvents.forEach((state2) => {
        state2.forEach((stop) => stop());
      });
      this.delayedEvents.clear();
    });
    __publicField(this, "stopActivities", (state2) => {
      var _a2, _b2;
      if (state2) {
        (_a2 = this.activityEvents.get(state2)) == null ? void 0 : _a2.forEach((stop) => stop());
        (_b2 = this.activityEvents.get(state2)) == null ? void 0 : _b2.clear();
        this.activityEvents.delete(state2);
      } else {
        this.activityEvents.forEach((state22) => {
          state22.forEach((stop) => stop());
          state22.clear();
        });
        this.activityEvents.clear();
      }
    });
    __publicField(this, "sendChild", (evt, to) => {
      const event2 = toEvent(evt);
      const id = runIfFn(to, this.contextSnapshot);
      const child = this.children.get(id);
      if (!child) {
        invariant(`[@zag-js/core] Cannot send '${event2.type}' event to unknown child`);
      }
      child.send(event2);
    });
    __publicField(this, "stopChild", (id) => {
      if (!this.children.has(id)) {
        invariant(`[@zag-js/core > stop-child] Cannot stop unknown child ${id}`);
      }
      this.children.get(id).stop();
      this.children.delete(id);
    });
    __publicField(this, "removeChild", (id) => {
      this.children.delete(id);
    });
    __publicField(this, "stopChildren", () => {
      this.children.forEach((child) => child.stop());
      this.children.clear();
    });
    __publicField(this, "setParent", (parent) => {
      this.parent = parent;
    });
    __publicField(this, "spawn", (src, id) => {
      const actor = runIfFn(src);
      if (id)
        actor.id = id;
      actor.type = "machine.actor";
      actor.setParent(this);
      this.children.set(actor.id, cast(actor));
      actor.onDone(() => {
        this.removeChild(actor.id);
      }).start();
      return cast(ref(actor));
    });
    __publicField(this, "addActivityCleanup", (state2, cleanup) => {
      var _a2;
      if (!state2)
        return;
      if (!this.activityEvents.has(state2)) {
        this.activityEvents.set(state2, /* @__PURE__ */ new Set([cleanup]));
      } else {
        (_a2 = this.activityEvents.get(state2)) == null ? void 0 : _a2.add(cleanup);
      }
    });
    __publicField(this, "setState", (target) => {
      this.state.previousValue = this.state.value;
      this.state.value = target;
      const stateNode = this.getStateNode(target);
      if (target == null) {
        clear(this.state.tags);
      } else {
        this.state.tags = toArray(stateNode == null ? void 0 : stateNode.tags);
      }
    });
    __publicField(this, "transformContext", (context) => {
      var _a2, _b2;
      (_b2 = (_a2 = this.options) == null ? void 0 : _a2.transformContext) == null ? void 0 : _b2.call(_a2, context);
      return context;
    });
    __publicField(this, "setContext", (context) => {
      if (!context)
        return;
      deepMerge(this.state.context, this.transformContext(context));
    });
    __publicField(this, "withContext", (context) => {
      const transformed = this.transformContext(context);
      const newContext = { ...this.config.context, ...compact(transformed) };
      return new _Machine({ ...this.config, context: newContext }, this.options);
    });
    __publicField(this, "setOptions", (options2) => {
      const opts = compact(options2);
      this.actionMap = { ...this.actionMap, ...opts.actions };
      this.delayMap = { ...this.delayMap, ...opts.delays };
      this.activityMap = { ...this.activityMap, ...opts.activities };
      this.guardMap = { ...this.guardMap, ...opts.guards };
    });
    __publicField(this, "getStateNode", (state2) => {
      var _a2;
      if (!state2)
        return;
      return (_a2 = this.config.states) == null ? void 0 : _a2[state2];
    });
    __publicField(this, "getNextStateInfo", (transitions, event2) => {
      const transition = this.determineTransition(transitions, event2);
      const isTargetless = !(transition == null ? void 0 : transition.target);
      const target = (transition == null ? void 0 : transition.target) ?? this.state.value;
      const changed = this.state.value !== target;
      const stateNode = this.getStateNode(target);
      const reenter = !isTargetless && !changed && !(transition == null ? void 0 : transition.internal);
      const info = {
        reenter,
        transition,
        stateNode,
        target,
        changed
      };
      this.log("NextState:", `[${event2.type}]`, this.state.value, "---->", info.target);
      return info;
    });
    __publicField(this, "getActionFromDelayedTransition", (transition) => {
      const event2 = toEvent(
        "machine.after"
        /* After */
      );
      const determineDelay = determineDelayFn(transition.delay, this.delayMap);
      const delay = determineDelay(this.contextSnapshot, event2);
      let id;
      return {
        entry: () => {
          id = globalThis.setTimeout(() => {
            const next = this.getNextStateInfo(transition, event2);
            this.performStateChangeEffects(this.state.value, next, event2);
          }, delay);
        },
        exit: () => {
          globalThis.clearTimeout(id);
        }
      };
    });
    __publicField(this, "getDelayedEventActions", (state2) => {
      const stateNode = this.getStateNode(state2);
      const event2 = toEvent(
        "machine.after"
        /* After */
      );
      if (!stateNode || !stateNode.after)
        return;
      const entries = [];
      const exits = [];
      if (isArray(stateNode.after)) {
        const transition = this.determineTransition(stateNode.after, event2);
        if (!transition)
          return;
        const actions = this.getActionFromDelayedTransition(transition);
        entries.push(actions.entry);
        exits.push(actions.exit);
      } else if (isObject2(stateNode.after)) {
        for (const delay in stateNode.after) {
          const transition = stateNode.after[delay];
          let resolvedTransition = {};
          if (isArray(transition)) {
            const picked = this.determineTransition(transition, event2);
            if (picked)
              resolvedTransition = picked;
          } else if (isString(transition)) {
            resolvedTransition = { target: transition, delay };
          } else {
            resolvedTransition = { ...transition, delay };
          }
          const actions = this.getActionFromDelayedTransition(resolvedTransition);
          entries.push(actions.entry);
          exits.push(actions.exit);
        }
      }
      return { entries, exits };
    });
    __publicField(this, "executeActions", (actions, event2) => {
      var _a2;
      const pickedActions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event2, this.guardMeta);
      for (const action of toArray(pickedActions)) {
        const fn = isString(action) ? (_a2 = this.actionMap) == null ? void 0 : _a2[action] : action;
        warn(
          isString(action) && !fn,
          `[@zag-js/core > execute-actions] No implementation found for action: \`${action}\``
        );
        fn == null ? void 0 : fn(this.state.context, event2, this.meta);
      }
    });
    __publicField(this, "executeActivities", (event2, activities, state2) => {
      var _a2;
      for (const activity of activities) {
        const fn = isString(activity) ? (_a2 = this.activityMap) == null ? void 0 : _a2[activity] : activity;
        if (!fn) {
          warn(`[@zag-js/core > execute-activity] No implementation found for activity: \`${activity}\``);
          continue;
        }
        const cleanup = fn(this.state.context, event2, this.meta);
        if (cleanup) {
          this.addActivityCleanup(state2 ?? this.state.value, cleanup);
        }
      }
    });
    __publicField(this, "createEveryActivities", (every, callbackfn) => {
      if (!every)
        return;
      const event2 = toEvent(
        "machine.every"
        /* Every */
      );
      if (isArray(every)) {
        const picked = toArray(every).find((transition) => {
          const delayOrFn = transition.delay;
          const determineDelay2 = determineDelayFn(delayOrFn, this.delayMap);
          const delay2 = determineDelay2(this.contextSnapshot, event2);
          const determineGuard = determineGuardFn(transition.guard, this.guardMap);
          const guard = determineGuard(this.contextSnapshot, event2, this.guardMeta);
          return guard ?? delay2 != null;
        });
        if (!picked)
          return;
        const determineDelay = determineDelayFn(picked.delay, this.delayMap);
        const delay = determineDelay(this.contextSnapshot, event2);
        const activity = () => {
          const id = globalThis.setInterval(() => {
            this.executeActions(picked.actions, event2);
          }, delay);
          return () => {
            globalThis.clearInterval(id);
          };
        };
        callbackfn(activity);
      } else {
        for (const interval in every) {
          const actions = every == null ? void 0 : every[interval];
          const determineDelay = determineDelayFn(interval, this.delayMap);
          const delay = determineDelay(this.contextSnapshot, event2);
          const activity = () => {
            const id = globalThis.setInterval(() => {
              this.executeActions(actions, event2);
            }, delay);
            return () => {
              globalThis.clearInterval(id);
            };
          };
          callbackfn(activity);
        }
      }
    });
    __publicField(this, "setEvent", (event2) => {
      this.state.previousEvent = this.state.event;
      this.state.event = ref(toEvent(event2));
    });
    __publicField(this, "performExitEffects", (current, event2) => {
      const currentState = this.state.value;
      if (currentState === "")
        return;
      const stateNode = current ? this.getStateNode(current) : void 0;
      this.stopActivities(currentState);
      const _exit = determineActionsFn(stateNode == null ? void 0 : stateNode.exit, this.guardMap)(this.contextSnapshot, event2, this.guardMeta);
      const exitActions = toArray(_exit);
      const afterExitActions = this.delayedEvents.get(currentState);
      if (afterExitActions) {
        exitActions.push(...afterExitActions);
      }
      this.executeActions(exitActions, event2);
      this.eventListeners.clear();
    });
    __publicField(this, "performEntryEffects", (next, event2) => {
      const stateNode = this.getStateNode(next);
      const activities = toArray(stateNode == null ? void 0 : stateNode.activities);
      this.createEveryActivities(stateNode == null ? void 0 : stateNode.every, (activity) => {
        activities.unshift(activity);
      });
      if (activities.length > 0) {
        this.executeActivities(event2, activities);
      }
      const pickedActions = determineActionsFn(stateNode == null ? void 0 : stateNode.entry, this.guardMap)(
        this.contextSnapshot,
        event2,
        this.guardMeta
      );
      const entryActions = toArray(pickedActions);
      const afterActions = this.getDelayedEventActions(next);
      if ((stateNode == null ? void 0 : stateNode.after) && afterActions) {
        this.delayedEvents.set(next, afterActions == null ? void 0 : afterActions.exits);
        entryActions.push(...afterActions.entries);
      }
      this.executeActions(entryActions, event2);
      if ((stateNode == null ? void 0 : stateNode.type) === "final") {
        this.state.done = true;
        this.doneListeners.forEach((listener) => {
          listener(this.stateSnapshot);
        });
        this.stop();
      }
    });
    __publicField(this, "performTransitionEffects", (transitions, event2) => {
      const transition = this.determineTransition(transitions, event2);
      this.executeActions(transition == null ? void 0 : transition.actions, event2);
    });
    __publicField(this, "performStateChangeEffects", (current, next, event2) => {
      this.setEvent(event2);
      const changed = next.changed || next.reenter;
      if (changed) {
        this.performExitEffects(current, event2);
      }
      this.performTransitionEffects(next.transition, event2);
      this.setState(next.target);
      if (changed) {
        this.performEntryEffects(next.target, event2);
      }
    });
    __publicField(this, "determineTransition", (transition, event2) => {
      const fn = determineTransitionFn(transition, this.guardMap);
      return fn == null ? void 0 : fn(this.contextSnapshot, event2, this.guardMeta);
    });
    __publicField(this, "sendParent", (evt) => {
      var _a2;
      if (!this.parent) {
        invariant("[@zag-js/core > send-parent] Cannot send event to an unknown parent");
      }
      const event2 = toEvent(evt);
      (_a2 = this.parent) == null ? void 0 : _a2.send(event2);
    });
    __publicField(this, "log", (...args) => {
      if (isDev2() && this.options.debug) {
        console.log(...args);
      }
    });
    __publicField(this, "send", (evt) => {
      const event2 = toEvent(evt);
      this.transition(this.state.value, event2);
    });
    __publicField(this, "transition", (state2, evt) => {
      var _a2, _b2;
      const stateNode = isString(state2) ? this.getStateNode(state2) : state2 == null ? void 0 : state2.stateNode;
      const event2 = toEvent(evt);
      if (!stateNode && !this.config.on) {
        const msg = this.status === "Stopped" ? "[@zag-js/core > transition] Cannot transition a stopped machine" : `[@zag-js/core > transition] State does not have a definition for \`state\`: ${state2}, \`event\`: ${event2.type}`;
        warn(msg);
        return;
      }
      const transitions = ((_a2 = stateNode == null ? void 0 : stateNode.on) == null ? void 0 : _a2[event2.type]) ?? ((_b2 = this.config.on) == null ? void 0 : _b2[event2.type]);
      const next = this.getNextStateInfo(transitions, event2);
      this.performStateChangeEffects(this.state.value, next, event2);
      return next.stateNode;
    });
    __publicField(this, "subscribe", (listener) => {
      this.stateListeners.add(listener);
      if (this.status === "Running") {
        listener(this.stateSnapshot);
      }
      return () => {
        this.stateListeners.delete(listener);
      };
    });
    __publicField(this, "onDone", (listener) => {
      this.doneListeners.add(listener);
      return this;
    });
    __publicField(this, "onTransition", (listener) => {
      this.stateListeners.add(listener);
      if (this.status === "Running") {
        listener(this.stateSnapshot);
      }
      return this;
    });
    __publicField(this, "onChange", (listener) => {
      this.contextListeners.add(listener);
      return this;
    });
    __publicField(this, "onEvent", (listener) => {
      this.eventListeners.add(listener);
      return this;
    });
    this.config = structuredClone(config);
    this.options = structuredClone(options ?? {});
    this.id = this.config.id ?? `machine-${uuid()}`;
    this.guardMap = ((_a = this.options) == null ? void 0 : _a.guards) ?? {};
    this.actionMap = ((_b = this.options) == null ? void 0 : _b.actions) ?? {};
    this.delayMap = ((_c = this.options) == null ? void 0 : _c.delays) ?? {};
    this.activityMap = ((_d = this.options) == null ? void 0 : _d.activities) ?? {};
    this.sync = ((_e = this.options) == null ? void 0 : _e.sync) ?? false;
    this.state = createProxy(this.config);
    this.initialContext = snapshot(this.state.context);
    this.transformContext(this.state.context);
    const event = toEvent(
      "machine.created"
      /* Created */
    );
    this.executeActions((_f = this.config) == null ? void 0 : _f.created, event);
  }
  // immutable state value
  get stateSnapshot() {
    return cast(snapshot(this.state));
  }
  getState() {
    return this.stateSnapshot;
  }
  // immutable context value
  get contextSnapshot() {
    return this.stateSnapshot.context;
  }
  /**
   * A reference to the instance methods of the machine.
   * Useful when spawning child machines and managing the communication between them.
   */
  get self() {
    const self = this;
    return {
      id: this.id,
      send: this.send.bind(this),
      sendParent: this.sendParent.bind(this),
      sendChild: this.sendChild.bind(this),
      stop: this.stop.bind(this),
      stopChild: this.stopChild.bind(this),
      spawn: this.spawn.bind(this),
      get state() {
        return self.stateSnapshot;
      },
      get initialContext() {
        return self.initialContext;
      },
      get initialState() {
        var _a;
        return ((_a = self.initialState) == null ? void 0 : _a.target) ?? "";
      }
    };
  }
  get meta() {
    var _a;
    return {
      state: this.stateSnapshot,
      guards: this.guardMap,
      send: this.send.bind(this),
      self: this.self,
      initialContext: this.initialContext,
      initialState: ((_a = this.initialState) == null ? void 0 : _a.target) ?? "",
      getState: () => this.stateSnapshot,
      getAction: (key) => this.actionMap[key],
      getGuard: (key) => this.guardMap[key]
    };
  }
  get guardMeta() {
    return {
      state: this.stateSnapshot
    };
  }
  get [Symbol.toStringTag]() {
    return "Machine";
  }
};
var createMachine = (config, options) => new Machine(config, options);

// node_modules/.pnpm/@zag-js+element-size@0.16.0/node_modules/@zag-js/element-size/dist/index.mjs
function trackElementSize(element, callback) {
  if (!element) {
    callback(void 0);
    return;
  }
  callback({ width: element.offsetWidth, height: element.offsetHeight });
  const win = element.ownerDocument.defaultView ?? window;
  const observer = new win.ResizeObserver((entries) => {
    if (!Array.isArray(entries) || !entries.length)
      return;
    const [entry] = entries;
    let width;
    let height;
    if ("borderBoxSize" in entry) {
      const borderSizeEntry = entry["borderBoxSize"];
      const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
      width = borderSize["inlineSize"];
      height = borderSize["blockSize"];
    } else {
      width = element.offsetWidth;
      height = element.offsetHeight;
    }
    callback({ width, height });
  });
  observer.observe(element, { box: "border-box" });
  return () => observer.unobserve(element);
}

// node_modules/.pnpm/@zag-js+utils@0.16.0/node_modules/@zag-js/utils/dist/index.mjs
var uuid2 = (() => {
  let id = 0;
  return () => {
    id++;
    return id.toString(36);
  };
})();
function compact2(obj) {
  if (!isPlainObject2(obj) || obj === void 0) {
    return obj;
  }
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact2(value);
    }
  }
  return filtered;
}
var isPlainObject2 = (value) => {
  return value && typeof value === "object" && value.constructor === Object;
};

// node_modules/.pnpm/@zag-js+slider@0.16.0/node_modules/@zag-js/slider/dist/index.mjs
var anatomy = createAnatomy("slider").parts(
  "root",
  "label",
  "thumb",
  "output",
  "track",
  "range",
  "control",
  "markerGroup",
  "marker"
);
var parts = anatomy.build();
function getVerticalThumbOffset(ctx) {
  const { height = 0 } = ctx.thumbSize ?? {};
  const getValue = getValueTransformer([ctx.min, ctx.max], [-height / 2, height / 2]);
  return parseFloat(getValue(ctx.value).toFixed(2));
}
function getHorizontalThumbOffset(ctx) {
  const { width = 0 } = ctx.thumbSize ?? {};
  if (ctx.isRtl) {
    const getValue2 = getValueTransformer([ctx.max, ctx.min], [-width * 1.5, -width / 2]);
    return -1 * parseFloat(getValue2(ctx.value).toFixed(2));
  }
  const getValue = getValueTransformer([ctx.min, ctx.max], [-width / 2, width / 2]);
  return parseFloat(getValue(ctx.value).toFixed(2));
}
function getThumbOffset(ctx) {
  const percent = getValuePercent(ctx.value, ctx.min, ctx.max) * 100;
  if (ctx.thumbAlignment === "center") {
    return `${percent}%`;
  }
  const offset = ctx.isVertical ? getVerticalThumbOffset(ctx) : getHorizontalThumbOffset(ctx);
  return `calc(${percent}% - ${offset}px)`;
}
function getVisibility(ctx) {
  let visibility = "visible";
  if (ctx.thumbAlignment === "contain" && !ctx.hasMeasuredThumbSize) {
    visibility = "hidden";
  }
  return visibility;
}
function getThumbStyle(ctx) {
  const placementProp = ctx.isVertical ? "bottom" : ctx.isRtl ? "right" : "left";
  return {
    visibility: getVisibility(ctx),
    position: "absolute",
    transform: "var(--slider-thumb-transform)",
    [placementProp]: "var(--slider-thumb-offset)"
  };
}
function getRangeOffsets(ctx) {
  let start = "0%";
  let end = `${100 - ctx.valuePercent}%`;
  if (ctx.origin === "center") {
    const isNegative = ctx.valuePercent < 50;
    start = isNegative ? `${ctx.valuePercent}%` : "50%";
    end = isNegative ? "50%" : end;
  }
  return { start, end };
}
function getRangeStyle(ctx) {
  if (ctx.isVertical) {
    return {
      position: "absolute",
      bottom: "var(--slider-range-start)",
      top: "var(--slider-range-end)"
    };
  }
  return {
    position: "absolute",
    [ctx.isRtl ? "right" : "left"]: "var(--slider-range-start)",
    [ctx.isRtl ? "left" : "right"]: "var(--slider-range-end)"
  };
}
function getControlStyle() {
  return {
    touchAction: "none",
    userSelect: "none",
    position: "relative"
  };
}
function getRootStyle(ctx) {
  const range = getRangeOffsets(ctx);
  return {
    "--slider-thumb-transform": ctx.isVertical ? "translateY(50%)" : "translateX(-50%)",
    "--slider-thumb-offset": getThumbOffset(ctx),
    "--slider-range-start": range.start,
    "--slider-range-end": range.end
  };
}
function getMarkerStyle(ctx, percent) {
  return {
    position: "absolute",
    pointerEvents: "none",
    [ctx.isHorizontal ? "left" : "bottom"]: `${(ctx.isRtl ? 1 - percent : percent) * 100}%`
  };
}
function getLabelStyle() {
  return { userSelect: "none" };
}
function getTrackStyle() {
  return { position: "relative" };
}
function getMarkerGroupStyle() {
  return {
    userSelect: "none",
    pointerEvents: "none",
    position: "relative"
  };
}
var styles = {
  getThumbOffset,
  getControlStyle,
  getThumbStyle,
  getRangeStyle,
  getRootStyle,
  getMarkerStyle,
  getLabelStyle,
  getTrackStyle,
  getMarkerGroupStyle
};
var dom = createScope({
  ...styles,
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `slider:${ctx.id}`;
  },
  getThumbId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.thumb) ?? `slider:${ctx.id}:thumb`;
  },
  getControlId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.control) ?? `slider:${ctx.id}:control`;
  },
  getHiddenInputId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.hiddenInput) ?? `slider:${ctx.id}:input`;
  },
  getOutputId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.output) ?? `slider:${ctx.id}:output`;
  },
  getTrackId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.track) ?? `slider:${ctx.id}track`;
  },
  getRangeId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.track) ?? `slider:${ctx.id}:range`;
  },
  getLabelId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.label) ?? `slider:${ctx.id}:label`;
  },
  getMarkerId: (ctx, value) => `slider:${ctx.id}:marker:${value}`,
  getRootEl: (ctx) => dom.getById(ctx, dom.getRootId(ctx)),
  getThumbEl: (ctx) => dom.getById(ctx, dom.getThumbId(ctx)),
  getControlEl: (ctx) => dom.getById(ctx, dom.getControlId(ctx)),
  getHiddenInputEl: (ctx) => dom.getById(ctx, dom.getHiddenInputId(ctx)),
  getValueFromPoint(ctx, point) {
    const controlEl = dom.getControlEl(ctx);
    if (!controlEl)
      return;
    const relativePoint = getRelativePoint(point, controlEl);
    const percent = relativePoint.getPercentValue({
      orientation: ctx.orientation,
      dir: ctx.dir,
      inverted: { y: true }
    });
    return getPercentValue(percent, ctx.min, ctx.max, ctx.step);
  },
  dispatchChangeEvent(ctx) {
    const input = dom.getHiddenInputEl(ctx);
    if (!input)
      return;
    dispatchInputValueEvent(input, { value: ctx.value });
  }
});
function connect(state2, send, normalize) {
  var _a, _b;
  const ariaLabel = state2.context["aria-label"];
  const ariaLabelledBy = state2.context["aria-labelledby"];
  const ariaValueText = (_b = (_a = state2.context).getAriaValueText) == null ? void 0 : _b.call(_a, state2.context.value);
  const isFocused = state2.matches("focus");
  const isDragging = state2.matches("dragging");
  const isDisabled = state2.context.disabled;
  const isInteractive = state2.context.isInteractive;
  const isInvalid = state2.context.invalid;
  function getPercentValueFn(percent) {
    return getPercentValue(percent, state2.context.min, state2.context.max, state2.context.step);
  }
  function getValuePercentFn(value) {
    return getValuePercent(value, state2.context.min, state2.context.max);
  }
  return {
    isFocused,
    isDragging,
    value: state2.context.value,
    percent: getValuePercent(state2.context.value, state2.context.min, state2.context.max),
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    getPercentValue: getPercentValueFn,
    getValuePercent: getValuePercentFn,
    focus() {
      var _a2;
      (_a2 = dom.getThumbEl(state2.context)) == null ? void 0 : _a2.focus();
    },
    /**
     * Function to increment the value of the slider by the step.
     */
    increment() {
      send("INCREMENT");
    },
    decrement() {
      send("DECREMENT");
    },
    rootProps: normalize.element({
      ...parts.root.attrs,
      "data-disabled": dataAttr(isDisabled),
      "data-focus": dataAttr(isFocused),
      "data-orientation": state2.context.orientation,
      "data-invalid": dataAttr(isInvalid),
      id: dom.getRootId(state2.context),
      dir: state2.context.dir,
      style: dom.getRootStyle(state2.context)
    }),
    labelProps: normalize.label({
      ...parts.label.attrs,
      "data-disabled": dataAttr(isDisabled),
      "data-invalid": dataAttr(isInvalid),
      "data-focus": dataAttr(isFocused),
      id: dom.getLabelId(state2.context),
      htmlFor: dom.getHiddenInputId(state2.context),
      onClick(event) {
        var _a2;
        if (!isInteractive)
          return;
        event.preventDefault();
        (_a2 = dom.getThumbEl(state2.context)) == null ? void 0 : _a2.focus();
      },
      style: dom.getLabelStyle()
    }),
    thumbProps: normalize.element({
      ...parts.thumb.attrs,
      id: dom.getThumbId(state2.context),
      "data-disabled": dataAttr(isDisabled),
      "data-orientation": state2.context.orientation,
      "data-focus": dataAttr(isFocused),
      draggable: false,
      "aria-invalid": ariaAttr(isInvalid),
      "data-invalid": dataAttr(isInvalid),
      "aria-disabled": ariaAttr(isDisabled),
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabel ? void 0 : ariaLabelledBy ?? dom.getLabelId(state2.context),
      "aria-orientation": state2.context.orientation,
      "aria-valuemax": state2.context.max,
      "aria-valuemin": state2.context.min,
      "aria-valuenow": state2.context.value,
      "aria-valuetext": ariaValueText,
      role: "slider",
      tabIndex: isDisabled ? void 0 : 0,
      onBlur() {
        if (!isInteractive)
          return;
        send("BLUR");
      },
      onFocus() {
        if (!isInteractive)
          return;
        send("FOCUS");
      },
      onKeyDown(event) {
        if (!isInteractive)
          return;
        const step = getEventStep(event) * state2.context.step;
        let prevent = true;
        const keyMap2 = {
          ArrowUp() {
            send({ type: "ARROW_UP", step });
            prevent = state2.context.isVertical;
          },
          ArrowDown() {
            send({ type: "ARROW_DOWN", step });
            prevent = state2.context.isVertical;
          },
          ArrowLeft() {
            send({ type: "ARROW_LEFT", step });
            prevent = state2.context.isHorizontal;
          },
          ArrowRight() {
            send({ type: "ARROW_RIGHT", step });
            prevent = state2.context.isHorizontal;
          },
          PageUp() {
            send({ type: "PAGE_UP", step });
          },
          PageDown() {
            send({ type: "PAGE_DOWN", step });
          },
          Home() {
            send("HOME");
          },
          End() {
            send("END");
          }
        };
        const key = getEventKey(event, state2.context);
        const exec = keyMap2[key];
        if (!exec)
          return;
        exec(event);
        if (prevent) {
          event.preventDefault();
        }
      },
      style: dom.getThumbStyle(state2.context)
    }),
    hiddenInputProps: normalize.input({
      type: "text",
      defaultValue: state2.context.value,
      name: state2.context.name,
      form: state2.context.form,
      id: dom.getHiddenInputId(state2.context),
      hidden: true
    }),
    outputProps: normalize.output({
      ...parts.output.attrs,
      "data-disabled": dataAttr(isDisabled),
      "data-invalid": dataAttr(isInvalid),
      "data-orientation": state2.context.orientation,
      id: dom.getOutputId(state2.context),
      htmlFor: dom.getHiddenInputId(state2.context),
      "aria-live": "off"
    }),
    trackProps: normalize.element({
      ...parts.track.attrs,
      id: dom.getTrackId(state2.context),
      "data-disabled": dataAttr(isDisabled),
      "data-focus": dataAttr(isFocused),
      "data-invalid": dataAttr(isInvalid),
      "data-orientation": state2.context.orientation,
      style: dom.getTrackStyle()
    }),
    rangeProps: normalize.element({
      ...parts.range.attrs,
      id: dom.getRangeId(state2.context),
      "data-focus": dataAttr(isFocused),
      "data-invalid": dataAttr(isInvalid),
      "data-disabled": dataAttr(isDisabled),
      "data-orientation": state2.context.orientation,
      style: dom.getRangeStyle(state2.context)
    }),
    controlProps: normalize.element({
      ...parts.control.attrs,
      id: dom.getControlId(state2.context),
      "data-disabled": dataAttr(isDisabled),
      "data-invalid": dataAttr(isInvalid),
      "data-orientation": state2.context.orientation,
      "data-focus": dataAttr(isFocused),
      onPointerDown(event) {
        if (!isInteractive)
          return;
        const evt = getNativeEvent(event);
        if (!isLeftClick(evt) || isModifiedEvent(evt))
          return;
        const point = getEventPoint(evt);
        send({ type: "POINTER_DOWN", point });
        event.preventDefault();
        event.stopPropagation();
      },
      style: dom.getControlStyle()
    }),
    markerGroupProps: normalize.element({
      ...parts.markerGroup.attrs,
      role: "presentation",
      "aria-hidden": true,
      "data-orientation": state2.context.orientation,
      style: dom.getMarkerGroupStyle()
    }),
    getMarkerProps({ value }) {
      const percent = getValuePercentFn(value);
      const style = dom.getMarkerStyle(state2.context, percent);
      const markerState = value > state2.context.value ? "over-value" : value < state2.context.value ? "under-value" : "at-value";
      return normalize.element({
        ...parts.marker.attrs,
        id: dom.getMarkerId(state2.context, value),
        role: "presentation",
        "data-orientation": state2.context.orientation,
        "data-value": value,
        "data-disabled": dataAttr(isDisabled),
        "data-state": markerState,
        style
      });
    }
  };
}
function constrainValue(ctx, value) {
  const snapValue = snapValueToStep(value, ctx.min, ctx.max, ctx.step);
  return clampValue(snapValue, ctx.min, ctx.max);
}
function decrement(ctx, step) {
  const index = 0;
  const values = getPreviousStepValue(index, {
    ...ctx,
    step: step ?? ctx.step,
    values: [ctx.value]
  });
  return values[index];
}
function increment(ctx, step) {
  const index = 0;
  const values = getNextStepValue(index, {
    ...ctx,
    step: step ?? ctx.step,
    values: [ctx.value]
  });
  return values[index];
}
function machine(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "slider",
      initial: "idle",
      context: {
        thumbSize: null,
        thumbAlignment: "contain",
        disabled: false,
        threshold: 5,
        dir: "ltr",
        origin: "start",
        orientation: "horizontal",
        initialValue: null,
        value: 0,
        step: 1,
        min: 0,
        max: 100,
        ...ctx
      },
      computed: {
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal",
        isVertical: (ctx2) => ctx2.orientation === "vertical",
        isRtl: (ctx2) => ctx2.orientation === "horizontal" && ctx2.dir === "rtl",
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly),
        hasMeasuredThumbSize: (ctx2) => ctx2.thumbSize !== null,
        valuePercent: (ctx2) => 100 * getValuePercent(ctx2.value, ctx2.min, ctx2.max)
      },
      watch: {
        value: ["invokeOnChange", "dispatchChangeEvent"]
      },
      activities: ["trackFormControlState", "trackThumbSize"],
      on: {
        SET_VALUE: {
          actions: "setValue"
        },
        INCREMENT: {
          actions: "increment"
        },
        DECREMENT: {
          actions: "decrement"
        }
      },
      entry: ["checkValue"],
      states: {
        idle: {
          on: {
            POINTER_DOWN: {
              target: "dragging",
              actions: ["setPointerValue", "invokeOnChangeStart", "focusThumb"]
            },
            FOCUS: "focus"
          }
        },
        focus: {
          entry: "focusThumb",
          on: {
            POINTER_DOWN: {
              target: "dragging",
              actions: ["setPointerValue", "invokeOnChangeStart", "focusThumb"]
            },
            ARROW_LEFT: {
              guard: "isHorizontal",
              actions: "decrement"
            },
            ARROW_RIGHT: {
              guard: "isHorizontal",
              actions: "increment"
            },
            ARROW_UP: {
              guard: "isVertical",
              actions: "increment"
            },
            ARROW_DOWN: {
              guard: "isVertical",
              actions: "decrement"
            },
            PAGE_UP: {
              actions: "increment"
            },
            PAGE_DOWN: {
              actions: "decrement"
            },
            HOME: {
              actions: "setToMin"
            },
            END: {
              actions: "setToMax"
            },
            BLUR: "idle"
          }
        },
        dragging: {
          entry: "focusThumb",
          activities: "trackPointerMove",
          on: {
            POINTER_UP: {
              target: "focus",
              actions: "invokeOnChangeEnd"
            },
            POINTER_MOVE: {
              actions: "setPointerValue"
            }
          }
        }
      }
    },
    {
      guards: {
        isHorizontal: (ctx2) => ctx2.isHorizontal,
        isVertical: (ctx2) => ctx2.isVertical
      },
      activities: {
        trackFormControlState(ctx2) {
          return trackFormControl(dom.getHiddenInputEl(ctx2), {
            onFieldsetDisabled() {
              ctx2.disabled = true;
            },
            onFormReset() {
              if (ctx2.initialValue != null) {
                ctx2.value = ctx2.initialValue;
              }
            }
          });
        },
        trackPointerMove(ctx2, _evt, { send }) {
          return trackPointerMove(dom.getDoc(ctx2), {
            onPointerMove(info) {
              send({ type: "POINTER_MOVE", point: info.point });
            },
            onPointerUp() {
              send("POINTER_UP");
            }
          });
        },
        trackThumbSize(ctx2, _evt) {
          if (ctx2.thumbAlignment !== "contain")
            return;
          return trackElementSize(dom.getThumbEl(ctx2), (size) => {
            if (size)
              ctx2.thumbSize = size;
          });
        }
      },
      actions: {
        checkValue(ctx2) {
          const value = constrainValue(ctx2, ctx2.value);
          ctx2.value = value;
          ctx2.initialValue = value;
        },
        invokeOnChangeStart(ctx2) {
          var _a;
          (_a = ctx2.onChangeStart) == null ? void 0 : _a.call(ctx2, { value: ctx2.value });
        },
        invokeOnChangeEnd(ctx2) {
          var _a;
          (_a = ctx2.onChangeEnd) == null ? void 0 : _a.call(ctx2, { value: ctx2.value });
        },
        invokeOnChange(ctx2) {
          var _a;
          (_a = ctx2.onChange) == null ? void 0 : _a.call(ctx2, { value: ctx2.value });
        },
        dispatchChangeEvent(ctx2) {
          dom.dispatchChangeEvent(ctx2);
        },
        setPointerValue(ctx2, evt) {
          const value = dom.getValueFromPoint(ctx2, evt.point);
          if (value == null)
            return;
          ctx2.value = clampValue(value, ctx2.min, ctx2.max);
        },
        focusThumb(ctx2) {
          raf(() => {
            var _a;
            return (_a = dom.getThumbEl(ctx2)) == null ? void 0 : _a.focus();
          });
        },
        decrement(ctx2, evt) {
          ctx2.value = decrement(ctx2, evt.step);
        },
        increment(ctx2, evt) {
          ctx2.value = increment(ctx2, evt.step);
        },
        setToMin(ctx2) {
          ctx2.value = ctx2.min;
        },
        setToMax(ctx2) {
          ctx2.value = ctx2.max;
        },
        setValue(ctx2, evt) {
          ctx2.value = constrainValue(ctx2, evt.value);
        }
      }
    }
  );
}
export {
  anatomy,
  connect,
  machine,
  dom as unstable__dom
};
//# sourceMappingURL=@zag-js_slider.js.map
