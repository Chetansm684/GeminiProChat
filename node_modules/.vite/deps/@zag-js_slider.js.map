{
  "version": 3,
  "sources": ["../../.pnpm/@zag-js+anatomy@0.16.0/node_modules/@zag-js/anatomy/src/create-anatomy.ts", "../../.pnpm/@zag-js+dom-query@0.16.0/node_modules/@zag-js/dom-query/src/attrs.ts", "../../.pnpm/@zag-js+dom-query@0.16.0/node_modules/@zag-js/dom-query/src/is-html-element.ts", "../../.pnpm/@zag-js+dom-query@0.16.0/node_modules/@zag-js/dom-query/src/contains.ts", "../../.pnpm/@zag-js+dom-query@0.16.0/node_modules/@zag-js/dom-query/src/create-scope.ts", "../../.pnpm/@zag-js+dom-query@0.16.0/node_modules/@zag-js/dom-query/src/env.ts", "../../.pnpm/@zag-js+dom-query@0.16.0/node_modules/@zag-js/dom-query/src/get-active-element.ts", "../../.pnpm/@zag-js+dom-query@0.16.0/node_modules/@zag-js/dom-query/src/get-by-id.ts", "../../.pnpm/@zag-js+dom-query@0.16.0/node_modules/@zag-js/dom-query/src/get-by-text.ts", "../../.pnpm/@zag-js+dom-query@0.16.0/node_modules/@zag-js/dom-query/src/get-by-typeahead.ts", "../../.pnpm/@zag-js+dom-query@0.16.0/node_modules/@zag-js/dom-query/src/get-computed-style.ts", "../../.pnpm/@zag-js+dom-query@0.16.0/node_modules/@zag-js/dom-query/src/get-event-target.ts", "../../.pnpm/@zag-js+dom-query@0.16.0/node_modules/@zag-js/dom-query/src/get-scroll-parent.ts", "../../.pnpm/@zag-js+dom-query@0.16.0/node_modules/@zag-js/dom-query/src/is-editable-element.ts", "../../.pnpm/@zag-js+dom-query@0.16.0/node_modules/@zag-js/dom-query/src/platform.ts", "../../.pnpm/@zag-js+dom-query@0.16.0/node_modules/@zag-js/dom-query/src/query.ts", "../../.pnpm/@zag-js+dom-query@0.16.0/node_modules/@zag-js/dom-query/src/raf.ts", "../../.pnpm/@zag-js+dom-query@0.16.0/node_modules/@zag-js/dom-query/src/index.ts", "../../.pnpm/@zag-js+text-selection@0.16.0/node_modules/@zag-js/text-selection/src/index.ts", "../../.pnpm/@zag-js+dom-event@0.16.0/node_modules/@zag-js/dom-event/src/add-dom-event.ts", "../../.pnpm/@zag-js+dom-event@0.16.0/node_modules/@zag-js/dom-event/src/assertion.ts", "../../.pnpm/@zag-js+dom-event@0.16.0/node_modules/@zag-js/dom-event/src/fire-event.ts", "../../.pnpm/@zag-js+dom-event@0.16.0/node_modules/@zag-js/dom-event/src/get-event-key.ts", "../../.pnpm/@zag-js+dom-event@0.16.0/node_modules/@zag-js/dom-event/src/get-event-point.ts", "../../.pnpm/@zag-js+dom-event@0.16.0/node_modules/@zag-js/dom-event/src/get-event-step.ts", "../../.pnpm/@zag-js+dom-event@0.16.0/node_modules/@zag-js/dom-event/src/get-native-event.ts", "../../.pnpm/@zag-js+dom-event@0.16.0/node_modules/@zag-js/dom-event/src/get-point-value.ts", "../../.pnpm/@zag-js+dom-event@0.16.0/node_modules/@zag-js/dom-event/src/request-pointer-lock.ts", "../../.pnpm/@zag-js+dom-event@0.16.0/node_modules/@zag-js/dom-event/src/track-pointer-move.ts", "../../.pnpm/@zag-js+dom-event@0.16.0/node_modules/@zag-js/dom-event/src/track-visual-viewport.ts", "../../.pnpm/@zag-js+numeric-range@0.16.0/node_modules/@zag-js/numeric-range/src/index.ts", "../../.pnpm/@zag-js+mutation-observer@0.16.0/node_modules/@zag-js/mutation-observer/src/observe-attributes.ts", "../../.pnpm/@zag-js+mutation-observer@0.16.0/node_modules/@zag-js/mutation-observer/src/observe-children.ts", "../../.pnpm/@zag-js+form-utils@0.16.0/node_modules/@zag-js/form-utils/src/input-event.ts", "../../.pnpm/@zag-js+form-utils@0.16.0/node_modules/@zag-js/form-utils/src/form.ts", "../../.pnpm/proxy-compare@2.5.1/node_modules/proxy-compare/src/index.ts", "../../.pnpm/@zag-js+store@0.16.0/node_modules/@zag-js/store/src/proxy.ts", "../../.pnpm/@zag-js+store@0.16.0/node_modules/@zag-js/store/src/proxy-computed.ts", "../../.pnpm/@zag-js+store@0.16.0/node_modules/@zag-js/store/src/subscribe-key.ts", "../../.pnpm/klona@2.0.6/node_modules/klona/full/index.mjs", "../../.pnpm/@zag-js+core@0.16.0/node_modules/@zag-js/core/src/index.ts", "../../.pnpm/@zag-js+core@0.16.0/node_modules/@zag-js/utilities/core/src/array.ts", "../../.pnpm/@zag-js+core@0.16.0/node_modules/@zag-js/utilities/core/src/functions.ts", "../../.pnpm/@zag-js+core@0.16.0/node_modules/@zag-js/utilities/core/src/guard.ts", "../../.pnpm/@zag-js+core@0.16.0/node_modules/@zag-js/utilities/core/src/object.ts", "../../.pnpm/@zag-js+core@0.16.0/node_modules/@zag-js/utilities/core/src/warning.ts", "../../.pnpm/@zag-js+core@0.16.0/node_modules/@zag-js/core/src/deep-merge.ts", "../../.pnpm/@zag-js+core@0.16.0/node_modules/@zag-js/core/src/utils.ts", "../../.pnpm/@zag-js+core@0.16.0/node_modules/@zag-js/core/src/guard-utils.ts", "../../.pnpm/@zag-js+core@0.16.0/node_modules/@zag-js/core/src/machine.ts", "../../.pnpm/@zag-js+core@0.16.0/node_modules/@zag-js/core/src/create-proxy.ts", "../../.pnpm/@zag-js+core@0.16.0/node_modules/@zag-js/core/src/delay-utils.ts", "../../.pnpm/@zag-js+core@0.16.0/node_modules/@zag-js/core/src/transition-utils.ts", "../../.pnpm/@zag-js+core@0.16.0/node_modules/@zag-js/core/src/merge-props.ts", "../../.pnpm/@zag-js+element-size@0.16.0/node_modules/@zag-js/element-size/src/track-size.ts", "../../.pnpm/@zag-js+element-size@0.16.0/node_modules/@zag-js/element-size/src/track-sizes.ts", "../../.pnpm/@zag-js+utils@0.16.0/node_modules/@zag-js/utils/src/array.ts", "../../.pnpm/@zag-js+utils@0.16.0/node_modules/@zag-js/utils/src/functions.ts", "../../.pnpm/@zag-js+utils@0.16.0/node_modules/@zag-js/utils/src/guard.ts", "../../.pnpm/@zag-js+utils@0.16.0/node_modules/@zag-js/utils/src/object.ts", "../../.pnpm/@zag-js+utils@0.16.0/node_modules/@zag-js/utils/src/warning.ts", "../../.pnpm/@zag-js+slider@0.16.0/node_modules/@zag-js/slider/src/slider.anatomy.ts", "../../.pnpm/@zag-js+slider@0.16.0/node_modules/@zag-js/slider/src/slider.connect.ts", "../../.pnpm/@zag-js+slider@0.16.0/node_modules/@zag-js/slider/src/slider.dom.ts", "../../.pnpm/@zag-js+slider@0.16.0/node_modules/@zag-js/slider/src/slider.style.ts", "../../.pnpm/@zag-js+slider@0.16.0/node_modules/@zag-js/slider/src/slider.machine.ts", "../../.pnpm/@zag-js+slider@0.16.0/node_modules/@zag-js/slider/src/slider.utils.ts"],
  "sourcesContent": ["export interface AnatomyPart {\n  selector: string\n  attrs: Record<\"data-scope\" | \"data-part\", string>\n}\n\nexport type AnatomyInstance<T extends string> = Omit<Anatomy<T>, \"parts\">\n\nexport type AnatomyPartName<T> = T extends AnatomyInstance<infer U> ? U : never\n\nexport interface Anatomy<T extends string> {\n  parts: <U extends string>(...parts: U[]) => AnatomyInstance<U>\n  extendWith: <V extends string>(...parts: V[]) => AnatomyInstance<T | V>\n  build: () => Record<T, AnatomyPart>\n  rename: (newName: string) => Anatomy<T>\n  keys: () => T[]\n}\n\nexport const createAnatomy = <T extends string>(name: string, parts = [] as T[]): Anatomy<T> => ({\n  parts: (...values) => {\n    if (isEmpty(parts)) {\n      return createAnatomy(name, values)\n    }\n    throw new Error(\"createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?\")\n  },\n  extendWith: (...values) => createAnatomy(name, [...parts, ...values]),\n  rename: (newName) => createAnatomy(newName, parts),\n  keys: () => parts,\n  build: () =>\n    [...new Set(parts)].reduce<Record<string, AnatomyPart>>(\n      (prev, part) =>\n        Object.assign(prev, {\n          [part]: {\n            selector: [\n              `&[data-scope=\"${toKebabCase(name)}\"][data-part=\"${toKebabCase(part)}\"]`,\n              `& [data-scope=\"${toKebabCase(name)}\"][data-part=\"${toKebabCase(part)}\"]`,\n            ].join(\", \"),\n            attrs: { \"data-scope\": toKebabCase(name), \"data-part\": toKebabCase(part) },\n          },\n        }),\n      {},\n    ),\n})\n\nconst toKebabCase = (value: string) =>\n  value\n    .replace(/([A-Z])([A-Z])/g, \"$1-$2\")\n    .replace(/([a-z])([A-Z])/g, \"$1-$2\")\n    .replace(/[\\s_]+/g, \"-\")\n    .toLowerCase()\n\nconst isEmpty = <T>(v: T[]): boolean => v.length === 0\n", "type Booleanish = boolean | \"true\" | \"false\"\n\nexport const dataAttr = (guard: boolean | undefined) => {\n  return (guard ? \"\" : undefined) as Booleanish\n}\n\nexport const ariaAttr = (guard: boolean | undefined) => {\n  return guard ? \"true\" : undefined\n}\n", "export function isHTMLElement(value: any): value is HTMLElement {\n  return typeof value === \"object\" && value?.nodeType === Node.ELEMENT_NODE && typeof value?.nodeName === \"string\"\n}\n", "import { isHTMLElement } from \"./is-html-element\"\n\ntype Target = HTMLElement | EventTarget | null | undefined\n\nexport function contains(parent: Target, child: Target) {\n  if (!parent || !child) return false\n  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false\n  return parent === child || parent.contains(child)\n}\n\nexport const isSelfEvent = (event: Pick<UIEvent, \"currentTarget\" | \"target\">) =>\n  contains(event.currentTarget, event.target)\n", "type Ctx = { getRootNode?: () => Document | ShadowRoot | Node }\n\nconst getDocument = (node: Document | ShadowRoot | Node) => {\n  if (node.nodeType === Node.DOCUMENT_NODE) return node as Document\n  return node.ownerDocument ?? document\n}\n\nexport function createScope<T>(methods: T) {\n  const screen = {\n    getRootNode: (ctx: Ctx) => (ctx.getRootNode?.() ?? document) as Document | ShadowRoot,\n    getDoc: (ctx: Ctx) => getDocument(screen.getRootNode(ctx)),\n    getWin: (ctx: Ctx) => screen.getDoc(ctx).defaultView ?? window,\n    getActiveElement: (ctx: Ctx) => screen.getDoc(ctx).activeElement as HTMLElement | null,\n    getById: <T extends HTMLElement = HTMLElement>(ctx: Ctx, id: string) =>\n      screen.getRootNode(ctx).getElementById(id) as T | null,\n  }\n  return { ...screen, ...methods }\n}\n", "const isDocument = (el: any): el is Document => el.nodeType === Node.DOCUMENT_NODE\n\nexport function getDocument(el: Element | Node | Document | null) {\n  if (isDocument(el)) return el\n  return el?.ownerDocument ?? document\n}\n\nexport function getWindow(el: HTMLElement) {\n  return el?.ownerDocument.defaultView ?? window\n}\n", "export function getActiveElement(el: HTMLElement): HTMLElement | null {\n  let activeElement = el.ownerDocument.activeElement as HTMLElement | null\n\n  while (activeElement?.shadowRoot) {\n    const el = activeElement.shadowRoot.activeElement as HTMLElement | null\n    if (el === activeElement) break\n    else activeElement = el\n  }\n\n  return activeElement\n}\n", "export function itemById<T extends HTMLElement>(v: T[], id: string) {\n  return v.find((node) => node.id === id)\n}\n\nexport function indexOfId<T extends HTMLElement>(v: T[], id: string) {\n  const item = itemById(v, id)\n  return item ? v.indexOf(item) : -1\n}\n\nexport function nextById<T extends HTMLElement>(v: T[], id: string, loop = true) {\n  let idx = indexOfId(v, id)\n  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1)\n  return v[idx]\n}\n\nexport function prevById<T extends HTMLElement>(v: T[], id: string, loop = true) {\n  let idx = indexOfId(v, id)\n  if (idx === -1) return loop ? v[v.length - 1] : null\n  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1)\n  return v[idx]\n}\n", "import { indexOfId } from \"./get-by-id\"\n\nconst getValueText = <T extends HTMLElement>(item: T) => item.dataset.valuetext ?? item.textContent ?? \"\"\n\nconst match = (valueText: string, query: string) => valueText.toLowerCase().startsWith(query.toLowerCase())\n\nconst wrap = <T>(v: T[], idx: number) => {\n  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length])\n}\n\nexport function getByText<T extends HTMLElement>(v: T[], text: string, currentId?: string | null) {\n  const index = currentId ? indexOfId(v, currentId) : -1\n  let items = currentId ? wrap(v, index) : v\n\n  const isSingleKey = text.length === 1\n\n  if (isSingleKey) {\n    items = items.filter((item) => item.id !== currentId)\n  }\n\n  return items.find((item) => match(getValueText(item), text))\n}\n", "import { getByText } from \"./get-by-text\"\n\nexport type TypeaheadState = {\n  keysSoFar: string\n  timer: number\n}\n\nexport type TypeaheadOptions = {\n  state: TypeaheadState\n  activeId: string | null\n  key: string\n  timeout?: number\n}\n\nfunction getByTypeaheadImpl<T extends HTMLElement>(_items: T[], options: TypeaheadOptions) {\n  const { state, activeId, key, timeout = 350 } = options\n\n  const search = state.keysSoFar + key\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0])\n\n  const query = isRepeated ? search[0] : search\n\n  let items = _items.slice()\n\n  const next = getByText(items, query, activeId)\n\n  function cleanup() {\n    clearTimeout(state.timer)\n    state.timer = -1\n  }\n\n  function update(value: string) {\n    state.keysSoFar = value\n    cleanup()\n\n    if (value !== \"\") {\n      state.timer = +setTimeout(() => {\n        update(\"\")\n        cleanup()\n      }, timeout)\n    }\n  }\n\n  update(search)\n\n  return next\n}\nexport const getByTypeahead = /*#__PURE__*/ Object.assign(getByTypeaheadImpl, {\n  defaultOptions: { keysSoFar: \"\", timer: -1 },\n  isValidEvent: isValidTypeaheadEvent,\n})\n\nfunction isValidTypeaheadEvent(event: Pick<KeyboardEvent, \"key\" | \"ctrlKey\" | \"metaKey\">) {\n  return event.key.length === 1 && !event.ctrlKey && !event.metaKey\n}\n", "const styleCache = new WeakMap<HTMLElement, any>()\n\nexport function getComputedStyle(el: HTMLElement) {\n  if (!styleCache.has(el)) {\n    const win = el.ownerDocument.defaultView || window\n    styleCache.set(el, win.getComputedStyle(el))\n  }\n  return styleCache.get(el)\n}\n", "export function getEventTarget<T extends EventTarget>(event: Event): T | null {\n  return (event.composedPath?.()[0] ?? event.target) as T | null\n}\n", "import { isHTMLElement } from \"./is-html-element\"\n\nfunction isScrollParent(el: HTMLElement): boolean {\n  const win = el.ownerDocument.defaultView || window\n  const { overflow, overflowX, overflowY } = win.getComputedStyle(el)\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX)\n}\n\nexport function getParent(el: HTMLElement): HTMLElement {\n  if (el.localName === \"html\") return el\n  return el.assignedSlot || el.parentElement || el.ownerDocument.documentElement\n}\n\nexport function getScrollParent(el: HTMLElement): HTMLElement {\n  if ([\"html\", \"body\", \"#document\"].includes(el.localName)) {\n    return el.ownerDocument.body\n  }\n\n  if (isHTMLElement(el) && isScrollParent(el)) {\n    return el\n  }\n\n  return getScrollParent(getParent(el))\n}\n\ntype Target = Array<VisualViewport | Window | HTMLElement | null>\n\nexport function getScrollParents(el: HTMLElement, list: Target = []): Target {\n  const parent = getScrollParent(el)\n  const isBody = parent === el.ownerDocument.body\n  const win = parent.ownerDocument.defaultView || window\n\n  //@ts-expect-error\n  const target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(parent) ? parent : []) : parent\n\n  const parents = list.concat(target)\n  return isBody ? parents : parents.concat(getScrollParents(getParent(<HTMLElement>target)))\n}\n", "import { isHTMLElement } from \"./is-html-element\"\n\nexport function isEditableElement(el: HTMLElement | EventTarget | null) {\n  if (el == null || !isHTMLElement(el)) {\n    return false\n  }\n\n  try {\n    const win = el.ownerDocument.defaultView || window\n    return (\n      (el instanceof win.HTMLInputElement && el.selectionStart != null) ||\n      /(textarea|select)/.test(el.localName) ||\n      el.isContentEditable\n    )\n  } catch {\n    return false\n  }\n}\n", "export const isDom = () => typeof document !== \"undefined\"\n\nexport function getPlatform() {\n  const agent = (navigator as any).userAgentData\n  return agent?.platform ?? navigator.platform\n}\n\nconst pt = (v: RegExp) => isDom() && v.test(getPlatform())\nconst ua = (v: RegExp) => isDom() && v.test(navigator.userAgent)\nconst vn = (v: RegExp) => isDom() && v.test(navigator.vendor)\n\nexport const isTouchDevice = () => isDom() && !!navigator.maxTouchPoints\nexport const isMac = () => pt(/^Mac/) && !isTouchDevice()\nexport const isIPhone = () => pt(/^iPhone/)\nexport const isSafari = () => isApple() && vn(/apple/i)\nexport const isFirefox = () => ua(/firefox\\//i)\nexport const isApple = () => pt(/mac|iphone|ipad|ipod/i)\nexport const isIos = () => isApple() && !isMac()\n", "type Root = Document | Element | null | undefined\n\nexport function queryAll<T extends HTMLElement = HTMLElement>(root: Root, selector: string) {\n  return Array.from(root?.querySelectorAll<T>(selector) ?? [])\n}\n\nexport function query<T extends HTMLElement = HTMLElement>(root: Root, selector: string) {\n  return root?.querySelector<T>(selector)\n}\n", "export function nextTick(fn: VoidFunction) {\n  const set = new Set<VoidFunction>()\n  function raf(fn: VoidFunction) {\n    const id = globalThis.requestAnimationFrame(fn)\n    set.add(() => globalThis.cancelAnimationFrame(id))\n  }\n  raf(() => raf(fn))\n  return function cleanup() {\n    set.forEach((fn) => fn())\n  }\n}\n\nexport function raf(fn: VoidFunction) {\n  const id = globalThis.requestAnimationFrame(fn)\n  return () => {\n    globalThis.cancelAnimationFrame(id)\n  }\n}\n", "export * from \"./attrs\"\nexport * from \"./contains\"\nexport * from \"./create-scope\"\nexport * from \"./env\"\nexport * from \"./get-active-element\"\nexport * from \"./get-by-id\"\nexport * from \"./get-by-text\"\nexport * from \"./get-by-typeahead\"\nexport * from \"./get-computed-style\"\nexport * from \"./get-event-target\"\nexport * from \"./get-scroll-parent\"\nexport * from \"./is-editable-element\"\nexport * from \"./is-html-element\"\nexport * from \"./platform\"\nexport * from \"./query\"\nexport * from \"./raf\"\n\nexport const MAX_Z_INDEX = 2147483647\n", "import { isIos, nextTick, raf } from \"@zag-js/dom-query\"\n\ntype State = \"default\" | \"disabled\" | \"restoring\"\n\nlet state: State = \"default\"\nlet userSelect = \"\"\nconst elementMap = new WeakMap<HTMLElement, string>()\n\nexport type DisableTextSelectionOptions<T = MaybeElement> = {\n  target?: T\n  doc?: Document\n  defer?: boolean\n}\n\nfunction disableTextSelectionImpl(options: DisableTextSelectionOptions = {}) {\n  const { target, doc } = options\n\n  const docNode = doc ?? document\n  const rootEl = docNode.documentElement\n\n  if (isIos()) {\n    if (state === \"default\") {\n      userSelect = rootEl.style.webkitUserSelect\n      rootEl.style.webkitUserSelect = \"none\"\n    }\n\n    state = \"disabled\"\n  } else if (target) {\n    elementMap.set(target, target.style.userSelect)\n    target.style.userSelect = \"none\"\n  }\n\n  return () => restoreTextSelection({ target, doc: docNode })\n}\n\nexport function restoreTextSelection(options: DisableTextSelectionOptions = {}) {\n  const { target, doc } = options\n\n  const docNode = doc ?? document\n  const rootEl = docNode.documentElement\n\n  if (isIos()) {\n    if (state !== \"disabled\") return\n    state = \"restoring\"\n\n    setTimeout(() => {\n      nextTick(() => {\n        if (state === \"restoring\") {\n          if (rootEl.style.webkitUserSelect === \"none\") {\n            rootEl.style.webkitUserSelect = userSelect || \"\"\n          }\n          userSelect = \"\"\n          state = \"default\"\n        }\n      })\n    }, 300)\n  } else {\n    if (target && elementMap.has(target)) {\n      const prevUserSelect = elementMap.get(target)\n\n      if (target.style.userSelect === \"none\") {\n        target.style.userSelect = prevUserSelect ?? \"\"\n      }\n\n      if (target.getAttribute(\"style\") === \"\") {\n        target.removeAttribute(\"style\")\n      }\n      elementMap.delete(target)\n    }\n  }\n}\n\ntype MaybeElement = HTMLElement | null | undefined\n\ntype NodeOrFn = MaybeElement | (() => MaybeElement)\n\nexport function disableTextSelection(options: DisableTextSelectionOptions<NodeOrFn> = {}) {\n  const { defer, target, ...restOptions } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const node = typeof target === \"function\" ? target() : target\n      cleanups.push(disableTextSelectionImpl({ ...restOptions, target: node }))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n", "interface EventMap extends DocumentEventMap, WindowEventMap, HTMLElementEventMap {}\n\ntype Node = Document | HTMLElement | EventTarget | null\n\ntype Target = (() => Node) | Node\n\nexport const addDomEvent = <K extends keyof EventMap>(\n  target: Target,\n  eventName: K,\n  handler: (event: EventMap[K]) => void,\n  options?: boolean | AddEventListenerOptions,\n) => {\n  const node = typeof target === \"function\" ? target() : target\n  node?.addEventListener(eventName, handler as any, options)\n  return () => {\n    node?.removeEventListener(eventName, handler as any, options)\n  }\n}\n", "export function isKeyboardClick(e: Pick<MouseEvent, \"detail\" | \"clientX\" | \"clientY\">) {\n  return e.detail === 0 || (e.clientX === 0 && e.clientY === 0)\n}\n\nexport function isPrintableKey(e: Pick<KeyboardEvent, \"key\" | \"ctrlKey\" | \"metaKey\">): boolean {\n  return e.key.length === 1 && !e.ctrlKey && !e.metaKey\n}\n\nexport function isVirtualPointerEvent(e: PointerEvent) {\n  return (\n    (e.width === 0 && e.height === 0) ||\n    (e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === \"mouse\")\n  )\n}\n\nexport function isVirtualClick(e: MouseEvent | PointerEvent): boolean {\n  if ((e as any).mozInputSource === 0 && e.isTrusted) return true\n  return e.detail === 0 && !(e as PointerEvent).pointerType\n}\n\nexport const isLeftClick = (e: Pick<MouseEvent, \"button\">) => e.button === 0\n\nexport const isContextMenuEvent = (e: Pick<MouseEvent, \"button\" | \"ctrlKey\" | \"metaKey\">) => {\n  return e.button === 2 || (isCtrlKey(e) && e.button === 0)\n}\n\nexport const isModifiedEvent = (e: Pick<KeyboardEvent, \"ctrlKey\" | \"metaKey\" | \"altKey\">) =>\n  e.ctrlKey || e.altKey || e.metaKey\n\nconst isMac = () => /Mac|iPod|iPhone|iPad/.test(window.navigator.platform)\n\nexport const isCtrlKey = (e: Pick<KeyboardEvent, \"ctrlKey\" | \"metaKey\">) =>\n  isMac() ? e.metaKey && !e.ctrlKey : e.ctrlKey && !e.metaKey\n", "export function fireCustomEvent(el: HTMLElement | null, type: string, init?: CustomEventInit) {\n  if (!el) return\n  const win = el.ownerDocument.defaultView || window\n  const event = new win.CustomEvent(type, init)\n  return el.dispatchEvent(event)\n}\n\nexport function fireBlurEvent(el: HTMLElement, init?: FocusEventInit) {\n  const win = el.ownerDocument.defaultView || window\n  const event = new win.FocusEvent(\"blur\", init)\n  const allowed = el.dispatchEvent(event)\n  const bubbleInit = { ...init, bubbles: true }\n  el.dispatchEvent(new win.FocusEvent(\"focusout\", bubbleInit))\n  return allowed\n}\n", "import type { EventKeyOptions } from \"./types\"\n\nconst keyMap = {\n  Up: \"ArrowUp\",\n  Down: \"ArrowDown\",\n  Esc: \"Escape\",\n  \" \": \"Space\",\n  \",\": \"Comma\",\n  Left: \"ArrowLeft\",\n  Right: \"ArrowRight\",\n}\n\nconst rtlKeyMap = {\n  ArrowLeft: \"ArrowRight\",\n  ArrowRight: \"ArrowLeft\",\n}\n\n/**\n * Determine the event key based on text direction.\n */\nexport function getEventKey(event: Pick<KeyboardEvent, \"key\">, options: EventKeyOptions = {}) {\n  const { dir = \"ltr\", orientation = \"horizontal\" } = options\n\n  let { key } = event\n  key = keyMap[key] ?? key // normalize key\n\n  const isRtl = dir === \"rtl\" && orientation === \"horizontal\"\n\n  if (isRtl && key in rtlKeyMap) {\n    key = rtlKeyMap[key]\n  }\n\n  return key\n}\n", "type PointType = \"page\" | \"client\"\n\nfunction pointFromTouch(e: TouchEvent, type: PointType = \"client\") {\n  const point = e.touches[0] || e.changedTouches[0]\n  return { x: point[`${type}X`], y: point[`${type}Y`] }\n}\n\nfunction pointFromMouse(point: MouseEvent | PointerEvent, type: PointType = \"client\") {\n  return { x: point[`${type}X`], y: point[`${type}Y`] }\n}\n\ntype AnyPointerEvent = MouseEvent | TouchEvent | PointerEvent\n\nconst isTouchEvent = (event: AnyPointerEvent): event is TouchEvent => \"touches\" in event && event.touches.length > 0\n\nexport function getEventPoint(event: AnyPointerEvent, type: PointType = \"client\") {\n  return isTouchEvent(event) ? pointFromTouch(event, type) : pointFromMouse(event, type)\n}\n", "const PAGE_KEYS = new Set([\"PageUp\", \"PageDown\"])\nconst ARROW_KEYS = new Set([\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"])\n\n/**\n * Determine the step factor for keyboard events\n */\nexport function getEventStep(event: Pick<KeyboardEvent, \"ctrlKey\" | \"metaKey\" | \"key\" | \"shiftKey\">) {\n  if (event.ctrlKey || event.metaKey) {\n    return 0.1\n  } else {\n    const isPageKey = PAGE_KEYS.has(event.key)\n    const isSkipKey = isPageKey || (event.shiftKey && ARROW_KEYS.has(event.key))\n    return isSkipKey ? 10 : 1\n  }\n}\n", "import type { JSX } from \"@zag-js/types\"\n\ntype NativeEvent<E> = JSX.ChangeEvent<any> extends E\n  ? InputEvent\n  : E extends JSX.SyntheticEvent<any, infer T>\n  ? T\n  : never\n\nexport function getNativeEvent<E>(event: E): NativeEvent<E> {\n  return (event as any).nativeEvent ?? event\n}\n", "function clamp(value: number) {\n  return Math.max(0, Math.min(1, value))\n}\n\nexport type Point = {\n  x: number\n  y: number\n}\n\ntype PercentValueOptions = {\n  inverted?: boolean | { x?: boolean; y?: boolean }\n  dir?: \"ltr\" | \"rtl\"\n  orientation?: \"vertical\" | \"horizontal\"\n}\n\nexport function getRelativePoint(point: Point, element: HTMLElement) {\n  const { left, top, width, height } = element.getBoundingClientRect()\n\n  const offset = { x: point.x - left, y: point.y - top }\n  const percent = { x: clamp(offset.x / width), y: clamp(offset.y / height) }\n\n  function getPercentValue(options: PercentValueOptions = {}) {\n    const { dir = \"ltr\", orientation = \"horizontal\", inverted } = options\n\n    const invertX = typeof inverted === \"object\" ? inverted.x : inverted\n    const invertY = typeof inverted === \"object\" ? inverted.y : inverted\n\n    if (orientation === \"horizontal\") {\n      return dir === \"rtl\" || invertX ? 1 - percent.x : percent.x\n    }\n\n    return invertY ? 1 - percent.y : percent.y\n  }\n\n  return { offset, percent, getPercentValue }\n}\n", "import { addDomEvent } from \"./add-dom-event\"\n\nexport function requestPointerLock(doc: Document, fn?: (locked: boolean) => void) {\n  const body = doc.body\n\n  const supported = \"pointerLockElement\" in doc || \"mozPointerLockElement\" in doc\n  const isLocked = () => !!doc.pointerLockElement\n\n  function onPointerChange() {\n    fn?.(isLocked())\n  }\n\n  function onPointerError(event: Event) {\n    if (isLocked()) fn?.(false)\n    console.error(\"PointerLock error occured:\", event)\n    doc.exitPointerLock()\n  }\n\n  if (!supported) return\n\n  try {\n    body.requestPointerLock()\n  } catch {}\n\n  // prettier-ignore\n  const cleanup = [\n    addDomEvent(doc, \"pointerlockchange\", onPointerChange, false),\n    addDomEvent(doc, \"pointerlockerror\", onPointerError, false)\n  ]\n\n  return () => {\n    cleanup.forEach((cleanup) => cleanup())\n    doc.exitPointerLock()\n  }\n}\n", "import { disableTextSelection } from \"@zag-js/text-selection\"\nimport { addDomEvent } from \"./add-dom-event\"\nimport { getEventPoint } from \"./get-event-point\"\n\ntype Point = {\n  x: number\n  y: number\n}\n\ntype PointerMoveHandlers = {\n  onPointerUp: VoidFunction\n  onPointerMove: (details: { point: Point; event: PointerEvent }) => void\n}\n\nexport function trackPointerMove(doc: Document, handlers: PointerMoveHandlers) {\n  const { onPointerMove, onPointerUp } = handlers\n\n  const handleMove = (event: PointerEvent) => {\n    const point = getEventPoint(event)\n\n    const distance = Math.sqrt(point.x ** 2 + point.y ** 2)\n    const moveBuffer = event.pointerType === \"touch\" ? 10 : 5\n\n    if (distance < moveBuffer) return\n\n    // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n    if (event.pointerType === \"mouse\" && event.button === 0) {\n      onPointerUp()\n      return\n    }\n\n    onPointerMove({ point, event })\n  }\n\n  const cleanups = [\n    addDomEvent(doc, \"pointermove\", handleMove, false),\n    addDomEvent(doc, \"pointerup\", onPointerUp, false),\n    addDomEvent(doc, \"pointercancel\", onPointerUp, false),\n    addDomEvent(doc, \"contextmenu\", onPointerUp, false),\n    disableTextSelection({ doc }),\n  ]\n\n  return () => {\n    cleanups.forEach((cleanup) => cleanup())\n  }\n}\n", "import { addDomEvent } from \"./add-dom-event\"\n\ntype ViewportSize = {\n  width: number\n  height: number\n}\n\nexport function trackVisualViewport(doc: Document, fn: (data: ViewportSize) => void) {\n  const win = doc?.defaultView || window\n\n  const onResize = () => {\n    fn?.(getViewportSize(win))\n  }\n\n  onResize()\n\n  return addDomEvent(win.visualViewport ?? win, \"resize\", onResize)\n}\n\nfunction getViewportSize(win: Window): ViewportSize {\n  return {\n    width: win.visualViewport?.width || win.innerWidth,\n    height: win.visualViewport?.height || win.innerHeight,\n  }\n}\n", "export function getMinValueAtIndex(index: number, values: number[], minValue: number) {\n  return index === 0 ? minValue : values[index - 1]\n}\n\nexport function getMaxValueAtIndex(index: number, values: number[], maxValue: number) {\n  return index === values.length - 1 ? maxValue : values[index + 1]\n}\n\nexport function isValueAtMax(value: number, maxValue: number) {\n  return value >= maxValue\n}\n\nexport function isValueAtMin(value: number, minValue: number) {\n  return value <= minValue\n}\n\nexport function isValueWithinRange(value: number, minValue: number, maxValue: number) {\n  return value >= minValue && value <= maxValue\n}\n\nexport function getRoundedValue(value: number, minValue: number, step: number) {\n  return Math.round((value - minValue) / step) * step + minValue\n}\n\nexport function clampValue(value: number, minValue: number, maxValue: number) {\n  return Math.min(Math.max(value, minValue), maxValue)\n}\n\nexport function getValuePercent(value: number, minValue: number, maxValue: number) {\n  return (value - minValue) / (maxValue - minValue)\n}\n\nexport function getPercentValue(percent: number, minValue: number, maxValue: number, step: number) {\n  const value = percent * (maxValue - minValue) + minValue\n  const roundedValue = getRoundedValue(value, minValue, step)\n  return clampValue(roundedValue, minValue, maxValue)\n}\n\nexport function snapValueToStep(value: number, min: number, max: number, step: number): number {\n  let remainder = (value - (isNaN(min) ? 0 : min)) % step\n  let snappedValue =\n    Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder\n\n  if (!isNaN(min)) {\n    if (snappedValue < min) {\n      snappedValue = min\n    } else if (!isNaN(max) && snappedValue > max) {\n      snappedValue = min + Math.floor((max - min) / step) * step\n    }\n  } else if (!isNaN(max) && snappedValue > max) {\n    snappedValue = Math.floor(max / step) * step\n  }\n\n  let string = step.toString()\n  let index = string.indexOf(\".\")\n  let precision = index >= 0 ? string.length - index : 0\n\n  if (precision > 0) {\n    let pow = Math.pow(10, precision)\n    snappedValue = Math.round(snappedValue * pow) / pow\n  }\n\n  return snappedValue\n}\n\nfunction setValueAtIndex<T>(values: T[], index: number, value: T) {\n  if (values[index] === value) return values\n  return [...values.slice(0, index), value, ...values.slice(index + 1)]\n}\n\ntype RangeContext = {\n  min: number\n  max: number\n  step: number\n  values: number[]\n}\n\nexport function getValueSetterAtIndex(index: number, ctx: RangeContext) {\n  const minValueAtIndex = getMinValueAtIndex(index, ctx.values, ctx.min)\n  const maxValueAtIndex = getMaxValueAtIndex(index, ctx.values, ctx.max)\n  let nextValues = ctx.values.slice()\n\n  return function setValue(value: number) {\n    let nextValue = snapValueToStep(value, minValueAtIndex, maxValueAtIndex, ctx.step)\n    nextValues = setValueAtIndex(nextValues, index, value)\n    nextValues[index] = nextValue\n    return nextValues\n  }\n}\n\nexport function getNextStepValue(index: number, ctx: RangeContext) {\n  const nextValue = ctx.values[index] + ctx.step\n  return getValueSetterAtIndex(index, ctx)(nextValue)\n}\n\nexport function getPreviousStepValue(index: number, ctx: RangeContext) {\n  const nextValue = ctx.values[index] - ctx.step\n  return getValueSetterAtIndex(index, ctx)(nextValue)\n}\n\nexport function getClosestValueIndex(values: number[], targetValue: number) {\n  let targetIndex = values.findIndex((value) => targetValue - value < 0)\n\n  // If the index is zero then the closetThumb is the first one\n  if (targetIndex === 0) {\n    return targetIndex\n  }\n\n  // If no index is found they've clicked past all the thumbs\n  if (targetIndex === -1) {\n    return values.length - 1\n  }\n\n  let valueBefore = values[targetIndex - 1]\n  let valueAfter = values[targetIndex]\n\n  // Pick the last left/start thumb, unless they are stacked on top of each other, then pick the right/end one\n  if (Math.abs(valueBefore - targetValue) < Math.abs(valueAfter - targetValue)) {\n    return targetIndex - 1\n  }\n\n  return targetIndex\n}\n\nexport function getValueRanges(values: number[], minValue: number, maxValue: number, gap: number) {\n  return values.map((value, index) => {\n    const min = index === 0 ? minValue : values[index - 1] + gap\n    const max = index === values.length - 1 ? maxValue : values[index + 1] - gap\n    return { min, max, value }\n  })\n}\n\nexport function getValueTransformer(valueA: number[], valueB: number[]) {\n  const input = { min: valueA[0], max: valueA[1] }\n  const output = { min: valueB[0], max: valueB[1] }\n\n  return function getValue(value: number) {\n    if (input.min === input.max || output.min === output.max) return output.min\n    const ratio = (output.max - output.min) / (input.max - input.min)\n    return output.min + ratio * (value - input.min)\n  }\n}\n", "export type ObserveAttributesCallback = (record: MutationRecord) => void\n\nexport function observeAttributes(node: HTMLElement | null, attributes: string[], fn: ObserveAttributesCallback) {\n  if (!node) return\n\n  const win = node.ownerDocument.defaultView || window\n\n  const obs = new win.MutationObserver((changes) => {\n    for (const change of changes) {\n      if (change.type === \"attributes\" && change.attributeName && attributes.includes(change.attributeName)) {\n        fn(change)\n      }\n    }\n  })\n\n  obs.observe(node, { attributes: true, attributeFilter: attributes })\n\n  return () => obs.disconnect()\n}\n", "export function observeChildren(node: HTMLElement | null, fn: (v: MutationRecord[]) => void) {\n  if (!node) return\n\n  const win = node.ownerDocument.defaultView || window\n\n  const obs = new win.MutationObserver(fn)\n  obs.observe(node, { childList: true, subtree: true })\n\n  return () => obs.disconnect()\n}\n", "type DescriptorOptions = {\n  type: \"HTMLInputElement\" | \"HTMLTextAreaElement\" | \"HTMLSelectElement\"\n  property?: \"value\" | \"checked\"\n}\n\nconst getWindow = (el: HTMLElement) => el.ownerDocument.defaultView || window\n\nfunction getDescriptor(el: HTMLElement, options: DescriptorOptions) {\n  const { type, property = \"value\" } = options\n  const proto = getWindow(el)[type].prototype\n  return Object.getOwnPropertyDescriptor(proto, property) ?? {}\n}\n\nexport function setElementValue(el: HTMLElement, value: string, option: DescriptorOptions) {\n  const descriptor = getDescriptor(el, option)\n  descriptor.set?.call(el, value)\n}\n\nexport type InputEventOptions = {\n  value: string | number\n  bubbles?: boolean\n}\n\nexport function dispatchInputValueEvent(el: HTMLElement | null, options: InputEventOptions) {\n  if (!el) return\n\n  const win = getWindow(el)\n  if (!(el instanceof win.HTMLInputElement)) return\n\n  const { value, bubbles = true } = options\n\n  // set property value\n  const descriptor = getDescriptor(el, {\n    type: \"HTMLInputElement\",\n    property: \"value\",\n  })\n\n  descriptor.set?.call(el, value)\n\n  // dispatch input event\n  const event = new win.Event(\"input\", { bubbles })\n  el.dispatchEvent(event)\n}\n\nexport type CheckedEventOptions = {\n  checked: boolean\n  bubbles?: boolean\n}\n\nexport function dispatchInputCheckedEvent(el: HTMLElement | null, options: CheckedEventOptions) {\n  if (!el) return\n\n  const win = getWindow(el)\n  if (!(el instanceof win.HTMLInputElement)) return\n\n  const { checked, bubbles = true } = options\n\n  // set property value\n  const descriptor = getDescriptor(el, {\n    type: \"HTMLInputElement\",\n    property: \"checked\",\n  })\n\n  descriptor.set?.call(el, checked)\n\n  // dispatch click event\n  const event = new win.Event(\"click\", { bubbles })\n  el.dispatchEvent(event)\n}\n", "import { observeAttributes } from \"@zag-js/mutation-observer\"\n\nexport function getClosestForm(el: HTMLElement) {\n  if (isFormElement(el)) return el.form\n  else return el.closest(\"form\")\n}\n\nfunction isFormElement(el: HTMLElement): el is HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement {\n  return el.matches(\"textarea, input, select, button\")\n}\n\nfunction trackFormReset(el: HTMLElement | null | undefined, callback: () => void) {\n  if (!el) return\n  const form = getClosestForm(el)\n  form?.addEventListener(\"reset\", callback, { passive: true })\n  return () => {\n    form?.removeEventListener(\"reset\", callback)\n  }\n}\n\nfunction trackFieldsetDisabled(el: HTMLElement | null | undefined, callback: (disabled: boolean) => void) {\n  const fieldset = el?.closest(\"fieldset\")\n  if (!fieldset) return\n  callback(fieldset.disabled)\n  return observeAttributes(fieldset, [\"disabled\"], () => callback(fieldset.disabled))\n}\n\nexport function isNativeDisabled(el: HTMLElement) {\n  return el.matches(\":disabled\")\n}\n\nexport type FormControlOptions = {\n  onFieldsetDisabled: () => void\n  onFormReset: () => void\n}\n\nexport function trackFormControl(el: HTMLElement | null, options: FormControlOptions) {\n  if (!el) return\n\n  const { onFieldsetDisabled, onFormReset } = options\n\n  const cleanups = [\n    trackFormReset(el, onFormReset),\n    trackFieldsetDisabled(el, (disabled) => {\n      if (disabled) onFieldsetDisabled()\n    }),\n  ]\n\n  return () => {\n    cleanups.forEach((cleanup) => cleanup?.())\n  }\n}\n", "// symbols\nconst TRACK_MEMO_SYMBOL = Symbol();\nconst GET_ORIGINAL_SYMBOL = Symbol();\n\n// properties\nconst AFFECTED_PROPERTY = 'a';\nconst IS_TARGET_COPIED_PROPERTY = 'f';\nconst PROXY_PROPERTY = 'p';\nconst PROXY_CACHE_PROPERTY = 'c';\nconst TARGET_CACHE_PROPERTY = 't';\nconst NEXT_OBJECT_PROPERTY = 'n';\nconst CHANGED_PROPERTY = 'g';\nconst HAS_KEY_PROPERTY = 'h';\nconst ALL_OWN_KEYS_PROPERTY = 'w';\nconst HAS_OWN_KEY_PROPERTY = 'o';\nconst KEYS_PROPERTY = 'k';\n\n// function to create a new bare proxy\nlet newProxy = <T extends object>(\n  target: T,\n  handler: ProxyHandler<T>,\n) => new Proxy(target, handler);\n\n// get object prototype\nconst getProto = Object.getPrototypeOf;\n\nconst objectsToTrack = new WeakMap<object, boolean>();\n\n// check if obj is a plain object or an array\nconst isObjectToTrack = <T>(obj: T): obj is T extends object ? T : never => (\n  obj && (objectsToTrack.has(obj as unknown as object)\n    ? objectsToTrack.get(obj as unknown as object) as boolean\n    : (getProto(obj) === Object.prototype || getProto(obj) === Array.prototype)\n  )\n);\n\n// check if it is object\nconst isObject = (x: unknown): x is object => (\n  typeof x === 'object' && x !== null\n);\n\n// Properties that are both non-configurable and non-writable will break\n// the proxy get trap when we try to return a recursive/child compare proxy\n// from them. We can avoid this by making a copy of the target object with\n// all descriptors marked as configurable, see `copyTargetObject`.\n// See: https://github.com/dai-shi/proxy-compare/pull/8\nconst needsToCopyTargetObject = (obj: object) => (\n  Object.values(Object.getOwnPropertyDescriptors(obj)).some(\n    (descriptor) => !descriptor.configurable && !descriptor.writable,\n  )\n);\n\n// Make a copy with all descriptors marked as configurable.\nconst copyTargetObject = <T extends object>(obj: T): T => {\n  if (Array.isArray(obj)) {\n    // Arrays need a special way to copy\n    return Array.from(obj) as T;\n  }\n  // For non-array objects, we create a new object keeping the prototype\n  // with changing all configurable options (otherwise, proxies will complain)\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  Object.values(descriptors).forEach((desc) => { desc.configurable = true; });\n  return Object.create(getProto(obj), descriptors);\n};\n\ntype HasKeySet = Set<string | symbol>\ntype HasOwnKeySet = Set<string | symbol>\ntype KeysSet = Set<string | symbol>\ntype Used = {\n  [HAS_KEY_PROPERTY]?: HasKeySet;\n  [ALL_OWN_KEYS_PROPERTY]?: true;\n  [HAS_OWN_KEY_PROPERTY]?: HasOwnKeySet;\n  [KEYS_PROPERTY]?: KeysSet;\n};\ntype Affected = WeakMap<object, Used>;\ntype ProxyHandlerState<T extends object> = {\n  readonly [IS_TARGET_COPIED_PROPERTY]: boolean;\n  [PROXY_PROPERTY]?: T;\n  [PROXY_CACHE_PROPERTY]?: ProxyCache<object> | undefined;\n  [TARGET_CACHE_PROPERTY]?: TargetCache<object> | undefined;\n  [AFFECTED_PROPERTY]?: Affected;\n}\ntype ProxyCache<T extends object> = WeakMap<\n  object,\n  readonly [ProxyHandler<T>, ProxyHandlerState<T>]\n>;\ntype TargetCache<T extends object> = WeakMap<\n  object,\n  readonly [target: T, copiedTarget?: T]\n>;\n\nconst createProxyHandler = <T extends object>(origObj: T, isTargetCopied: boolean) => {\n  const state: ProxyHandlerState<T> = {\n    [IS_TARGET_COPIED_PROPERTY]: isTargetCopied,\n  };\n  let trackObject = false; // for trackMemo\n  const recordUsage = (\n    type:\n      | typeof HAS_KEY_PROPERTY\n      | typeof ALL_OWN_KEYS_PROPERTY\n      | typeof HAS_OWN_KEY_PROPERTY\n      | typeof KEYS_PROPERTY,\n    key?: string | symbol,\n  ) => {\n    if (!trackObject) {\n      let used = (state[AFFECTED_PROPERTY] as Affected).get(origObj);\n      if (!used) {\n        used = {};\n        (state[AFFECTED_PROPERTY] as Affected).set(origObj, used);\n      }\n      if (type === ALL_OWN_KEYS_PROPERTY) {\n        used[ALL_OWN_KEYS_PROPERTY] = true;\n      } else {\n        let set = used[type];\n        if (!set) {\n          set = new Set();\n          used[type] = set;\n        }\n        set.add(key as string | symbol);\n      }\n    }\n  };\n  const recordObjectAsUsed = () => {\n    trackObject = true;\n    (state[AFFECTED_PROPERTY] as Affected).delete(origObj);\n  };\n  const handler: ProxyHandler<T> = {\n    get(target, key) {\n      if (key === GET_ORIGINAL_SYMBOL) {\n        return origObj;\n      }\n      recordUsage(KEYS_PROPERTY, key);\n      return createProxy(\n        Reflect.get(target, key),\n        (state[AFFECTED_PROPERTY] as Affected),\n        state[PROXY_CACHE_PROPERTY],\n        state[TARGET_CACHE_PROPERTY],\n      );\n    },\n    has(target, key) {\n      if (key === TRACK_MEMO_SYMBOL) {\n        recordObjectAsUsed();\n        return true;\n      }\n      recordUsage(HAS_KEY_PROPERTY, key);\n      return Reflect.has(target, key);\n    },\n    getOwnPropertyDescriptor(target, key) {\n      recordUsage(HAS_OWN_KEY_PROPERTY, key);\n      return Reflect.getOwnPropertyDescriptor(target, key);\n    },\n    ownKeys(target) {\n      recordUsage(ALL_OWN_KEYS_PROPERTY);\n      return Reflect.ownKeys(target);\n    },\n  };\n  if (isTargetCopied) {\n    handler.set = handler.deleteProperty = () => false;\n  }\n  return [handler, state] as const;\n};\n\nconst getOriginalObject = <T extends object>(obj: T) => (\n  // unwrap proxy\n  (obj as { [GET_ORIGINAL_SYMBOL]?: typeof obj })[GET_ORIGINAL_SYMBOL]\n  // otherwise\n  || obj\n);\n\n/**\n * Create a proxy.\n *\n * This function will create a proxy at top level and proxy nested objects as you access them,\n * in order to keep track of which properties were accessed via get/has proxy handlers:\n *\n * NOTE: Printing of WeakMap is hard to inspect and not very readable\n * for this purpose you can use the `affectedToPathList` helper.\n *\n * @param {object} obj - Object that will be wrapped on the proxy.\n * @param {WeakMap<object, unknown>} affected -\n * WeakMap that will hold the tracking of which properties in the proxied object were accessed.\n * @param {WeakMap<object, unknown>} [proxyCache] -\n * WeakMap that will help keep referential identity for proxies.\n * @returns {Proxy<object>} - Object wrapped in a proxy.\n *\n * @example\n * import { createProxy } from 'proxy-compare';\n *\n * const original = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n * const proxy = createProxy(original, affected);\n *\n * proxy.a // Will mark as used and track its value.\n * // This will update the affected WeakMap with original as key\n * // and a Set with \"a\"\n *\n * proxy.d // Will mark \"d\" as accessed to track and proxy itself ({ e: \"3\" }).\n * // This will update the affected WeakMap with original as key\n * // and a Set with \"d\"\n */\nexport const createProxy = <T>(\n  obj: T,\n  affected: WeakMap<object, unknown>,\n  proxyCache?: WeakMap<object, unknown>,\n  targetCache?: WeakMap<object, unknown>,\n): T => {\n  if (!isObjectToTrack(obj)) return obj;\n  let targetAndCopied = (\n    targetCache && (targetCache as TargetCache<typeof obj>).get(obj)\n  );\n  if (!targetAndCopied) {\n    const target = getOriginalObject(obj);\n    if (needsToCopyTargetObject(target)) {\n      targetAndCopied = [target, copyTargetObject(target)];\n    } else {\n      targetAndCopied = [target];\n    }\n    targetCache?.set(obj, targetAndCopied);\n  }\n  const [target, copiedTarget] = targetAndCopied;\n  let handlerAndState = (\n    proxyCache && (proxyCache as ProxyCache<typeof target>).get(target)\n  );\n  if (\n    !handlerAndState\n    || handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget\n  ) {\n    handlerAndState = createProxyHandler<typeof target>(target, !!copiedTarget);\n    handlerAndState[1][PROXY_PROPERTY] = newProxy(\n      copiedTarget || target,\n      handlerAndState[0],\n    );\n    if (proxyCache) {\n      proxyCache.set(target, handlerAndState);\n    }\n  }\n  handlerAndState[1][AFFECTED_PROPERTY] = affected as Affected;\n  handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache as ProxyCache<object> | undefined;\n  handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache as TargetCache<object> | undefined;\n  return handlerAndState[1][PROXY_PROPERTY] as typeof target;\n};\n\nconst isAllOwnKeysChanged = (prevObj: object, nextObj: object) => {\n  const prevKeys = Reflect.ownKeys(prevObj);\n  const nextKeys = Reflect.ownKeys(nextObj);\n  return prevKeys.length !== nextKeys.length\n    || prevKeys.some((k, i) => k !== nextKeys[i]);\n};\n\ntype ChangedCache = WeakMap<object, {\n  [NEXT_OBJECT_PROPERTY]: object;\n  [CHANGED_PROPERTY]: boolean;\n}>;\n\n/**\n * Compare changes on objects.\n *\n * This will compare the affected properties on tracked objects inside the proxy\n * to check if there were any changes made to it,\n * by default if no property was accessed on the proxy it will attempt to do a\n * reference equality check for the objects provided (Object.is(a, b)). If you access a property\n * on the proxy, then isChanged will only compare the affected properties.\n *\n * @param {object} prevObj - The previous object to compare.\n * @param {object} nextObj - Object to compare with the previous one.\n * @param {WeakMap<object, unknown>} affected -\n * WeakMap that holds the tracking of which properties in the proxied object were accessed.\n * @param {WeakMap<object, unknown>} [cache] -\n * WeakMap that holds a cache of the comparisons for better performance with repetitive comparisons,\n * and to avoid infinite loop with circular structures.\n * @returns {boolean} - Boolean indicating if the affected property on the object has changed.\n *\n * @example\n * import { createProxy, isChanged } from 'proxy-compare';\n *\n * const obj = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(obj, affected);\n *\n * proxy.a\n *\n * isChanged(obj, { a: \"1\" }, affected) // false\n *\n * proxy.a = \"2\"\n *\n * isChanged(obj, { a: \"1\" }, affected) // true\n */\n\nexport const isChanged = (\n  prevObj: unknown,\n  nextObj: unknown,\n  affected: WeakMap<object, unknown>,\n  cache?: WeakMap<object, unknown>,\n): boolean => {\n  if (Object.is(prevObj, nextObj)) {\n    return false;\n  }\n  if (!isObject(prevObj) || !isObject(nextObj)) return true;\n  const used = (affected as Affected).get(getOriginalObject(prevObj));\n  if (!used) return true;\n  if (cache) {\n    const hit = (cache as ChangedCache).get(prevObj);\n    if (hit && hit[NEXT_OBJECT_PROPERTY] === nextObj) {\n      return hit[CHANGED_PROPERTY];\n    }\n    // for object with cycles\n    (cache as ChangedCache).set(prevObj, {\n      [NEXT_OBJECT_PROPERTY]: nextObj,\n      [CHANGED_PROPERTY]: false,\n    });\n  }\n  let changed: boolean | null = null;\n  try {\n    for (const key of used[HAS_KEY_PROPERTY] || []) {\n      changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);\n      if (changed) return changed;\n    }\n    if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n      changed = isAllOwnKeysChanged(prevObj, nextObj);\n      if (changed) return changed;\n    } else {\n      for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {\n        const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);\n        const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);\n        changed = hasPrev !== hasNext;\n        if (changed) return changed;\n      }\n    }\n    for (const key of used[KEYS_PROPERTY] || []) {\n      changed = isChanged(\n        (prevObj as any)[key],\n        (nextObj as any)[key],\n        affected,\n        cache,\n      );\n      if (changed) return changed;\n    }\n    if (changed === null) changed = true;\n    return changed;\n  } finally {\n    if (cache) {\n      cache.set(prevObj, {\n        [NEXT_OBJECT_PROPERTY]: nextObj,\n        [CHANGED_PROPERTY]: changed,\n      });\n    }\n  }\n};\n\n// explicitly track object with memo\nexport const trackMemo = (obj: unknown) => {\n  if (isObjectToTrack(obj)) {\n    return TRACK_MEMO_SYMBOL in obj;\n  }\n  return false;\n};\n\n/**\n * Unwrap proxy to get the original object.\n *\n * Used to retrieve the original object used to create the proxy instance with `createProxy`.\n *\n * @param {Proxy<object>} obj -  The proxy wrapper of the originial object.\n * @returns {object | null} - Return either the unwrapped object if exists.\n *\n * @example\n * import { createProxy, getUntracked } from 'proxy-compare';\n *\n * const original = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(original, affected);\n * const originalFromProxy = getUntracked(proxy)\n *\n * Object.is(original, originalFromProxy) // true\n * isChanged(original, originalFromProxy, affected) // false\n */\nexport const getUntracked = <T>(obj: T): T | null => {\n  if (isObjectToTrack(obj)) {\n    return (obj as { [GET_ORIGINAL_SYMBOL]?: T })[GET_ORIGINAL_SYMBOL] || null;\n  }\n  return null;\n};\n\n/**\n * Mark object to be tracked.\n *\n * This function marks an object that will be passed into `createProxy`\n * as marked to track or not. By default only Array and Object are marked to track,\n * so this is useful for example to mark a class instance to track or to mark a object\n * to be untracked when creating your proxy.\n *\n * @param obj - Object to mark as tracked or not.\n * @param mark - Boolean indicating whether you want to track this object or not.\n * @returns - No return.\n *\n * @example\n * import { createProxy, markToTrack, isChanged } from 'proxy-compare';\n *\n * const nested = { e: \"3\" }\n *\n * markToTrack(nested, false)\n *\n * const original = { a: \"1\", c: \"2\", d: nested };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(original, affected);\n *\n * proxy.d.e\n *\n * isChanged(original, { d: { e: \"3\" } }, affected) // true\n */\nexport const markToTrack = (obj: object, mark = true) => {\n  objectsToTrack.set(obj, mark);\n};\n\n/**\n * Convert `affected` to path list\n *\n * `affected` is a weak map which is not printable.\n * This function is can convert it to printable path list.\n * It's for debugging purpose.\n *\n * @param obj - An object that is used with `createProxy`.\n * @param affected - A weak map that is used with `createProxy`.\n * @param onlyWithValues - An optional boolean to exclude object getters.\n * @returns - An array of paths.\n */\nexport const affectedToPathList = (\n  obj: unknown,\n  affected: WeakMap<object, unknown>,\n  onlyWithValues?: boolean,\n) => {\n  const list: (string | symbol)[][] = [];\n  const seen = new WeakSet();\n  const walk = (x: unknown, path?: (string | symbol)[]) => {\n    if (seen.has(x as object)) {\n      // for object with cycles\n      return;\n    }\n    if (isObject(x)) {\n      seen.add(x);\n    }\n    const used = isObject(x) && (affected as Affected).get(getOriginalObject(x));\n    if (used) {\n      used[HAS_KEY_PROPERTY]?.forEach((key) => {\n        const segment = `:has(${String(key)})`;\n        list.push(path ? [...path, segment] : [segment]);\n      });\n      if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n        const segment = ':ownKeys';\n        list.push(path ? [...path, segment] : [segment]);\n      } else {\n        used[HAS_OWN_KEY_PROPERTY]?.forEach((key) => {\n          const segment = `:hasOwn(${String(key)})`;\n          list.push(path ? [...path, segment] : [segment]);\n        });\n      }\n      used[KEYS_PROPERTY]?.forEach((key) => {\n        if (!onlyWithValues || 'value' in (Object.getOwnPropertyDescriptor(x, key) || {})) {\n          walk((x as any)[key], path ? [...path, key] : [key]);\n        }\n      });\n    } else if (path) {\n      list.push(path);\n    }\n  };\n  walk(obj);\n  return list;\n};\n\n/**\n * replace newProxy function.\n *\n * This can be used if you want to use proxy-polyfill.\n * Note that proxy-polyfill can't polyfill everything.\n * Use it at your own risk.\n */\nexport const replaceNewProxy = (fn: typeof newProxy) => {\n  newProxy = fn;\n};\n", "// Credits: https://github.com/pmndrs/valtio\n\nimport { getUntracked, markToTrack } from \"proxy-compare\"\n\nconst isDev = process.env.NODE_ENV !== \"production\"\nconst isObject = (x: unknown): x is object => typeof x === \"object\" && x !== null\n\ntype AsRef = { $$valtioRef: true }\n\ntype ProxyObject = object\n\ntype Path = (string | symbol)[]\ntype Op =\n  | [op: \"set\", path: Path, value: unknown, prevValue: unknown]\n  | [op: \"delete\", path: Path, prevValue: unknown]\n  | [op: \"resolve\", path: Path, value: unknown]\n  | [op: \"reject\", path: Path, error: unknown]\ntype Listener = (op: Op, nextVersion: number) => void\n\ntype AnyFunction = (...args: any[]) => any\n\nexport type Snapshot<T> = T extends AnyFunction\n  ? T\n  : T extends AsRef\n  ? T\n  : T extends Promise<any>\n  ? Awaited<T>\n  : {\n      readonly [K in keyof T]: Snapshot<T[K]>\n    }\n\ntype HandlePromise = <P extends Promise<any>>(promise: P) => Awaited<P>\n\ntype CreateSnapshot = <T extends object>(target: T, version: number, handlePromise?: HandlePromise) => T\n\ntype RemoveListener = () => void\ntype AddListener = (listener: Listener) => RemoveListener\n\ntype ProxyState = readonly [\n  target: object,\n  ensureVersion: (nextCheckVersion?: number) => number,\n  createSnapshot: CreateSnapshot,\n  addListener: AddListener,\n]\n\n// shared state\nconst proxyStateMap = new WeakMap<ProxyObject, ProxyState>()\nconst refSet = new WeakSet()\n\nconst buildProxyFunction = (\n  objectIs = Object.is,\n\n  newProxy = <T extends object>(target: T, handler: ProxyHandler<T>): T => new Proxy(target, handler),\n\n  canProxy = (x: unknown) =>\n    isObject(x) &&\n    !refSet.has(x) &&\n    (Array.isArray(x) || !(Symbol.iterator in x)) &&\n    !(x instanceof WeakMap) &&\n    !(x instanceof WeakSet) &&\n    !(x instanceof Error) &&\n    !(x instanceof Number) &&\n    !(x instanceof Date) &&\n    !(x instanceof String) &&\n    !(x instanceof RegExp) &&\n    !(x instanceof ArrayBuffer),\n\n  defaultHandlePromise = <P extends Promise<any>>(\n    promise: P & {\n      status?: \"pending\" | \"fulfilled\" | \"rejected\"\n      value?: Awaited<P>\n      reason?: unknown\n    },\n  ) => {\n    switch (promise.status) {\n      case \"fulfilled\":\n        return promise.value as Awaited<P>\n      case \"rejected\":\n        throw promise.reason\n      default:\n        throw promise\n    }\n  },\n\n  snapCache = new WeakMap<object, [version: number, snap: unknown]>(),\n\n  createSnapshot: CreateSnapshot = <T extends object>(\n    target: T,\n    version: number,\n    handlePromise: HandlePromise = defaultHandlePromise,\n  ): T => {\n    const cache = snapCache.get(target)\n    if (cache?.[0] === version) {\n      return cache[1] as T\n    }\n    const snap: any = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target))\n    markToTrack(snap, true) // mark to track\n    snapCache.set(target, [version, snap])\n    Reflect.ownKeys(target).forEach((key) => {\n      const value = Reflect.get(target, key)\n      if (refSet.has(value as object)) {\n        markToTrack(value as object, false) // mark not to track\n        snap[key] = value\n      } else if (value instanceof Promise) {\n        Object.defineProperty(snap, key, {\n          get() {\n            return handlePromise(value)\n          },\n        })\n      } else if (proxyStateMap.has(value as object)) {\n        snap[key] = snapshot(value as object, handlePromise)\n      } else {\n        snap[key] = value\n      }\n    })\n    return Object.freeze(snap)\n  },\n\n  proxyCache = new WeakMap<object, ProxyObject>(),\n\n  versionHolder = [1, 1] as [number, number],\n\n  proxyFunction = <T extends object>(initialObject: T): T => {\n    if (!isObject(initialObject)) {\n      throw new Error(\"object required\")\n    }\n    const found = proxyCache.get(initialObject) as T | undefined\n    if (found) {\n      return found\n    }\n    let version = versionHolder[0]\n    const listeners = new Set<Listener>()\n    const notifyUpdate = (op: Op, nextVersion = ++versionHolder[0]) => {\n      if (version !== nextVersion) {\n        version = nextVersion\n        listeners.forEach((listener) => listener(op, nextVersion))\n      }\n    }\n    let checkVersion = versionHolder[1]\n    const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {\n      if (checkVersion !== nextCheckVersion && !listeners.size) {\n        checkVersion = nextCheckVersion\n        propProxyStates.forEach(([propProxyState]) => {\n          const propVersion = propProxyState[1](nextCheckVersion)\n          if (propVersion > version) {\n            version = propVersion\n          }\n        })\n      }\n      return version\n    }\n    const createPropListener =\n      (prop: string | symbol): Listener =>\n      (op, nextVersion) => {\n        const newOp: Op = [...op]\n        newOp[1] = [prop, ...(newOp[1] as Path)]\n        notifyUpdate(newOp, nextVersion)\n      }\n    const propProxyStates = new Map<string | symbol, readonly [ProxyState, RemoveListener?]>()\n    const addPropListener = (prop: string | symbol, propProxyState: ProxyState) => {\n      if (isDev && propProxyStates.has(prop)) {\n        throw new Error(\"prop listener already exists\")\n      }\n      if (listeners.size) {\n        const remove = propProxyState[3](createPropListener(prop))\n        propProxyStates.set(prop, [propProxyState, remove])\n      } else {\n        propProxyStates.set(prop, [propProxyState])\n      }\n    }\n    const removePropListener = (prop: string | symbol) => {\n      const entry = propProxyStates.get(prop)\n      if (entry) {\n        propProxyStates.delete(prop)\n        entry[1]?.()\n      }\n    }\n    const addListener = (listener: Listener) => {\n      listeners.add(listener)\n      if (listeners.size === 1) {\n        propProxyStates.forEach(([propProxyState, prevRemove], prop) => {\n          if (isDev && prevRemove) {\n            throw new Error(\"remove already exists\")\n          }\n          const remove = propProxyState[3](createPropListener(prop))\n          propProxyStates.set(prop, [propProxyState, remove])\n        })\n      }\n      const removeListener = () => {\n        listeners.delete(listener)\n        if (listeners.size === 0) {\n          propProxyStates.forEach(([propProxyState, remove], prop) => {\n            if (remove) {\n              remove()\n              propProxyStates.set(prop, [propProxyState])\n            }\n          })\n        }\n      }\n      return removeListener\n    }\n    const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject))\n    const handler: ProxyHandler<T> = {\n      deleteProperty(target: T, prop: string | symbol) {\n        const prevValue = Reflect.get(target, prop)\n        removePropListener(prop)\n        const deleted = Reflect.deleteProperty(target, prop)\n        if (deleted) {\n          notifyUpdate([\"delete\", [prop], prevValue])\n        }\n        return deleted\n      },\n      set(target: T, prop: string | symbol, value: any, receiver: object) {\n        const hasPrevValue = Reflect.has(target, prop)\n        const prevValue = Reflect.get(target, prop, receiver)\n        if (\n          hasPrevValue &&\n          (objectIs(prevValue, value) || (proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value))))\n        ) {\n          return true\n        }\n        removePropListener(prop)\n        if (isObject(value)) {\n          value = getUntracked(value) || value\n        }\n        let nextValue = value\n        if (Object.getOwnPropertyDescriptor(target, prop)?.set) {\n          // do nothing\n        } else if (value instanceof Promise) {\n          value\n            .then((v) => {\n              value.status = \"fulfilled\"\n              value.value = v\n              notifyUpdate([\"resolve\", [prop], v])\n            })\n            .catch((e) => {\n              value.status = \"rejected\"\n              value.reason = e\n              notifyUpdate([\"reject\", [prop], e])\n            })\n        } else {\n          if (!proxyStateMap.has(value) && canProxy(value)) {\n            nextValue = proxy(value)\n          }\n          const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue)\n          if (childProxyState) {\n            addPropListener(prop, childProxyState)\n          }\n        }\n        Reflect.set(target, prop, nextValue, receiver)\n        notifyUpdate([\"set\", [prop], value, prevValue])\n        return true\n      },\n    }\n    const proxyObject = newProxy(baseObject, handler)\n    proxyCache.set(initialObject, proxyObject)\n    const proxyState: ProxyState = [baseObject, ensureVersion, createSnapshot, addListener]\n    proxyStateMap.set(proxyObject, proxyState)\n    Reflect.ownKeys(initialObject).forEach((key) => {\n      const desc = Object.getOwnPropertyDescriptor(initialObject, key) as PropertyDescriptor\n      if (desc.get || desc.set) {\n        Object.defineProperty(baseObject, key, desc)\n      } else {\n        proxyObject[key as keyof T] = initialObject[key as keyof T]\n      }\n    })\n    return proxyObject\n  },\n) =>\n  [\n    // public functions\n    proxyFunction,\n    // shared state\n    proxyStateMap,\n    refSet,\n    // internal things\n    objectIs,\n    newProxy,\n    canProxy,\n    defaultHandlePromise,\n    snapCache,\n    createSnapshot,\n    proxyCache,\n    versionHolder,\n  ] as const\n\nconst [proxyFunction] = buildProxyFunction()\n\nexport function proxy<T extends object>(initialObject: T = {} as T): T {\n  return proxyFunction(initialObject)\n}\n\nexport function getVersion(proxyObject: unknown): number | undefined {\n  const proxyState = proxyStateMap.get(proxyObject as object)\n  return proxyState?.[1]()\n}\n\nexport function subscribe<T extends object>(\n  proxyObject: T,\n  callback: (ops: Op[]) => void,\n  notifyInSync?: boolean,\n): () => void {\n  const proxyState = proxyStateMap.get(proxyObject as object)\n  if (isDev && !proxyState) {\n    console.warn(\"Please use proxy object\")\n  }\n  let promise: Promise<void> | undefined\n  const ops: Op[] = []\n  const addListener = (proxyState as ProxyState)[3]\n  let isListenerActive = false\n  const listener: Listener = (op) => {\n    ops.push(op)\n    if (notifyInSync) {\n      callback(ops.splice(0))\n      return\n    }\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = undefined\n        if (isListenerActive) {\n          callback(ops.splice(0))\n        }\n      })\n    }\n  }\n  const removeListener = addListener(listener)\n  isListenerActive = true\n  return () => {\n    isListenerActive = false\n    removeListener()\n  }\n}\n\nexport function snapshot<T extends object>(proxyObject: T, handlePromise?: HandlePromise): Snapshot<T> {\n  const proxyState = proxyStateMap.get(proxyObject as object)\n  if (isDev && !proxyState) {\n    console.warn(\"Please use proxy object\")\n  }\n  const [target, ensureVersion, createSnapshot] = proxyState as ProxyState\n  return createSnapshot(target, ensureVersion(), handlePromise) as Snapshot<T>\n}\n\nexport function ref<T extends object>(obj: T): T & AsRef {\n  refSet.add(obj)\n  return obj as T & AsRef\n}\n", "import { proxy, snapshot, type Snapshot } from \"./proxy\"\n\nexport function proxyWithComputed<T extends object, U extends object>(\n  initialObject: T,\n  computedFns: {\n    [K in keyof U]:\n      | ((snap: Snapshot<T>) => U[K])\n      | {\n          get: (snap: Snapshot<T>) => U[K]\n          set?: (state: T, newValue: U[K]) => void\n        }\n  },\n) {\n  const keys = Object.keys(computedFns) as (keyof U)[]\n  keys.forEach((key) => {\n    if (Object.getOwnPropertyDescriptor(initialObject, key)) {\n      throw new Error(\"object property already defined\")\n    }\n    const computedFn = computedFns[key]\n    const { get, set } = (typeof computedFn === \"function\" ? { get: computedFn } : computedFn) as {\n      get: (snap: Snapshot<T>) => U[typeof key]\n      set?: (state: T, newValue: U[typeof key]) => void\n    }\n    const desc: PropertyDescriptor = {}\n    desc.get = () => get(snapshot(proxyObject))\n    if (set) {\n      desc.set = (newValue) => set(proxyObject, newValue)\n    }\n    Object.defineProperty(initialObject, key, desc)\n  })\n  const proxyObject = proxy(initialObject) as T & U\n  return proxyObject\n}\n", "import { snapshot, subscribe } from \"./proxy\"\n\nexport type CompareFn<T = any> = (prev: T, next: T) => boolean\n\nconst defaultCompareFn: CompareFn = (prev, next) => Object.is(prev, next)\n\nexport function subscribeKey<T extends object, K extends keyof T>(\n  obj: T,\n  key: K,\n  fn: (value: T[K]) => void,\n  sync?: boolean,\n  compareFn?: (prev: T[K], next: T[K]) => boolean,\n) {\n  let prev: any = Reflect.get(snapshot(obj), key)\n  const isEqual = compareFn || defaultCompareFn\n  function onSnapshotChange() {\n    const snap = snapshot(obj) as T\n    if (isEqual(prev, snap[key])) return\n    fn(snap[key])\n    prev = Reflect.get(snap, key)\n  }\n  return subscribe(obj, onSnapshotChange, sync)\n}\n", "function set(obj, key, val) {\n\tif (typeof val.value === 'object') val.value = klona(val.value);\n\tif (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === '__proto__') {\n\t\tObject.defineProperty(obj, key, val);\n\t} else obj[key] = val.value;\n}\n\nexport function klona(x) {\n\tif (typeof x !== 'object') return x;\n\n\tvar i=0, k, list, tmp, str=Object.prototype.toString.call(x);\n\n\tif (str === '[object Object]') {\n\t\ttmp = Object.create(x.__proto__ || null);\n\t} else if (str === '[object Array]') {\n\t\ttmp = Array(x.length);\n\t} else if (str === '[object Set]') {\n\t\ttmp = new Set;\n\t\tx.forEach(function (val) {\n\t\t\ttmp.add(klona(val));\n\t\t});\n\t} else if (str === '[object Map]') {\n\t\ttmp = new Map;\n\t\tx.forEach(function (val, key) {\n\t\t\ttmp.set(klona(key), klona(val));\n\t\t});\n\t} else if (str === '[object Date]') {\n\t\ttmp = new Date(+x);\n\t} else if (str === '[object RegExp]') {\n\t\ttmp = new RegExp(x.source, x.flags);\n\t} else if (str === '[object DataView]') {\n\t\ttmp = new x.constructor( klona(x.buffer) );\n\t} else if (str === '[object ArrayBuffer]') {\n\t\ttmp = x.slice(0);\n\t} else if (str.slice(-6) === 'Array]') {\n\t\t// ArrayBuffer.isView(x)\n\t\t// ~> `new` bcuz `Buffer.slice` => ref\n\t\ttmp = new x.constructor(x);\n\t}\n\n\tif (tmp) {\n\t\tfor (list=Object.getOwnPropertySymbols(x); i < list.length; i++) {\n\t\t\tset(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));\n\t\t}\n\n\t\tfor (i=0, list=Object.getOwnPropertyNames(x); i < list.length; i++) {\n\t\t\tif (Object.hasOwnProperty.call(tmp, k=list[i]) && tmp[k] === x[k]) continue;\n\t\t\tset(tmp, k, Object.getOwnPropertyDescriptor(x, k));\n\t\t}\n\t}\n\n\treturn tmp || x;\n}\n", "export { proxy, ref, snapshot, subscribe } from \"@zag-js/store\"\nexport { deepMerge } from \"./deep-merge\"\nexport { choose, guards } from \"./guard-utils\"\nexport * from \"./machine\"\nexport { mergeProps } from \"./merge-props\"\nexport type { ContextFrom, EventFrom, StateFrom } from \"./type-utils\"\nexport type { StateMachine } from \"./types\"\n", "export function toArray<T>(v: T | T[] | undefined | null): T[] {\n  if (!v) return []\n  return Array.isArray(v) ? v : [v]\n}\n\nexport const fromLength = (length: number) => Array.from(Array(length).keys())\n\nexport const first = <T>(v: T[]): T | undefined => v[0]\n\nexport const last = <T>(v: T[]): T | undefined => v[v.length - 1]\n\nexport const isEmpty = <T>(v: T[]): boolean => v.length === 0\n\nexport const has = <T>(v: T[], t: any): boolean => v.indexOf(t) !== -1\n\nexport const add = <T>(v: T[], ...items: T[]): T[] => v.concat(items)\n\nexport const remove = <T>(v: T[], item: T): T[] => removeAt(v, v.indexOf(item))\n\nexport const removeAt = <T>(v: T[], i: number): T[] => {\n  if (i > -1) v.splice(i, 1)\n  return v\n}\n\nexport function clear<T>(v: T[]): T[] {\n  while (v.length > 0) v.pop()\n  return v\n}\n\nexport type IndexOptions = {\n  step?: number\n  loop?: boolean\n}\n\nexport function nextIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  const next = idx + step\n  const len = v.length\n  const last = len - 1\n  if (idx === -1) return step > 0 ? 0 : last\n  if (next < 0) return loop ? last : 0\n  if (next >= len) return loop ? 0 : idx > len ? len : idx\n  return next\n}\n\nexport function next<T>(v: T[], idx: number, opts: IndexOptions = {}): T | undefined {\n  return v[nextIndex(v, idx, opts)]\n}\n\nexport function prevIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  return nextIndex(v, idx, { step: -step, loop })\n}\n\nexport function prev<T>(v: T[], index: number, opts: IndexOptions = {}): T | undefined {\n  return v[prevIndex(v, index, opts)]\n}\n\nexport const chunk = <T>(v: T[], size: number): T[][] => {\n  const res: T[][] = []\n  return v.reduce((rows, value, index) => {\n    if (index % size === 0) rows.push([value])\n    else last(rows)?.push(value)\n    return rows\n  }, res)\n}\n", "export const runIfFn = <T>(\n  v: T | undefined,\n  ...a: T extends (...a: any[]) => void ? Parameters<T> : never\n): T extends (...a: any[]) => void ? NonNullable<ReturnType<T>> : NonNullable<T> => {\n  const res = typeof v === \"function\" ? v(...a) : v\n  return res ?? undefined\n}\n\nexport const cast = <T>(v: unknown): T => v as T\n\nexport const noop = () => {}\n\nexport const callAll =\n  <T extends (...a: any[]) => void>(...fns: (T | undefined)[]) =>\n  (...a: Parameters<T>) => {\n    fns.forEach(function (fn) {\n      fn?.(...a)\n    })\n  }\n\nexport const uuid = /*#__PURE__*/ (() => {\n  let id = 0\n  return () => {\n    id++\n    return id.toString(36)\n  }\n})()\n", "export const isDev = () => process.env.NODE_ENV !== \"production\"\nexport const isArray = (v: any): v is any[] => Array.isArray(v)\nexport const isBoolean = (v: any): v is boolean => v === true || v === false\nexport const isObject = (v: any): v is Record<string, any> => !(v == null || typeof v !== \"object\" || isArray(v))\nexport const isNumber = (v: any): v is number => typeof v === \"number\" && !Number.isNaN(v)\nexport const isString = (v: any): v is string => typeof v === \"string\"\nexport const isFunction = (v: any): v is Function => typeof v === \"function\"\n\nexport const hasProp = <T extends string>(obj: any, prop: T): obj is Record<T, any> =>\n  Object.prototype.hasOwnProperty.call(obj, prop)\n", "export function compact<T extends Record<string, unknown> | undefined>(obj: T): T {\n  if (!isPlainObject(obj) || obj === undefined) {\n    return obj\n  }\n\n  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === \"string\")\n  const filtered: Partial<T> = {}\n  for (const key of keys) {\n    const value = (obj as any)[key]\n    if (value !== undefined) {\n      filtered[key as keyof T] = compact(value)\n    }\n  }\n  return filtered as T\n}\n\nexport function json(value: any) {\n  return JSON.parse(JSON.stringify(value))\n}\n\nconst isPlainObject = (value: any) => {\n  return value && typeof value === \"object\" && value.constructor === Object\n}\n", "export function warn(m: string): void\nexport function warn(c: boolean, m: string): void\nexport function warn(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    console.warn(m)\n  }\n}\n\nexport function invariant(m: string): void\nexport function invariant(c: boolean, m: string): void\nexport function invariant(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    throw new Error(m)\n  }\n}\n", "import { compact, isObject } from \"@zag-js/utils\"\n\nexport function deepMerge<T extends Record<string, any>>(source: T, ...objects: T[]): T {\n  for (const obj of objects) {\n    const target = compact(obj)\n    for (const key in target) {\n      if (isObject(obj[key])) {\n        if (!source[key]) {\n          source[key] = {} as any\n        }\n        deepMerge(source[key], obj[key])\n      } else {\n        source[key] = obj[key]\n      }\n    }\n  }\n  return source\n}\n", "import { isArray, isObject, isString } from \"@zag-js/utils\"\nimport { klona } from \"klona/full\"\nimport type { Dict, StateMachine as S } from \"./types\"\n\nexport function structuredClone<T>(v: T): T {\n  return klona(v)\n}\n\nexport function toEvent<T extends S.EventObject>(event: S.Event<T>): T {\n  const obj = isString(event) ? { type: event } : event\n  return obj as T\n}\n\nexport function toArray<T>(value: T | T[] | undefined): T[] {\n  if (!value) return []\n  return isArray(value) ? value.slice() : [value]\n}\n\nexport function isGuardHelper(value: any): value is { predicate: (guards: Dict) => any } {\n  return isObject(value) && value.predicate != null\n}\n", "import { isFunction, isString } from \"@zag-js/utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\nimport { isGuardHelper } from \"./utils\"\n\nconst Truthy = () => true\n\n/* -----------------------------------------------------------------------------\n * The following functions are used to determine a guard's truthiness\n * -----------------------------------------------------------------------------*/\n\nfunction exec<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  guardMap: Dict,\n  ctx: TContext,\n  event: TEvent,\n  meta: S.GuardMeta<TContext, TState, TEvent>,\n) {\n  return (guard: S.Guard<TContext, TState, TEvent>) => {\n    if (isString(guard)) {\n      return !!guardMap[guard]?.(ctx, event, meta)\n    }\n    if (isFunction(guard)) {\n      return guard(ctx, event, meta)\n    }\n    return guard.predicate(guardMap)(ctx, event, meta)\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Guard helpers (for combining guards)\n * -----------------------------------------------------------------------------*/\n\nfunction or<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...conditions: Array<S.Guard<TContext, TState, TEvent>>\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      conditions.map(exec(guardMap, ctx, event, meta)).some(Boolean),\n  }\n}\n\nfunction and<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...conditions: Array<S.Guard<TContext, TState, TEvent>>\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      conditions.map(exec(guardMap, ctx, event, meta)).every(Boolean),\n  }\n}\n\nfunction not<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  condition: S.Guard<TContext, TState, TEvent>,\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n      return !exec(guardMap, ctx, event, meta)(condition)\n    },\n  }\n}\n\nfunction stateIn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...values: TState[\"value\"][]\n): S.GuardExpression<TContext, TState, TEvent> {\n  return (_ctx, _evt, meta) => meta.state.matches(...values)\n}\n\nexport const guards = { or, and, not, stateIn }\n\n/* -----------------------------------------------------------------------------\n * Action guard helper. Used to determie the action to be taken\n * -----------------------------------------------------------------------------*/\n\nexport function choose<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n>(\n  actions: Array<{ guard?: S.Guard<TContext, TState, TEvent>; actions: S.PureActions<TContext, TState, TEvent> }>,\n): S.ChooseHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      actions.find((def) => {\n        const guard = def.guard ?? Truthy\n        return exec(guardMap, ctx, event, meta)(guard)\n      })?.actions,\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Function to determine the guard to be used\n * -----------------------------------------------------------------------------*/\n\nexport function determineGuardFn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  guard: S.Guard<TContext, TState, TEvent> | undefined,\n  guardMap: S.GuardMap<TContext, TState, TEvent>,\n) {\n  guard = guard ?? Truthy\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    if (isString(guard)) {\n      const value = guardMap[guard]\n      return isFunction(value) ? value(context, event, meta) : value\n    }\n\n    if (isGuardHelper(guard)) {\n      return guard.predicate(guardMap)(context, event, meta)\n    }\n\n    return guard?.(context, event, meta)\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Function to determine the actions to be taken\n * -----------------------------------------------------------------------------*/\n\nexport function determineActionsFn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  values: S.Actions<TContext, TState, TEvent> | undefined,\n  guardMap: S.GuardMap<TContext, TState, TEvent>,\n) {\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    if (isGuardHelper(values)) {\n      return values.predicate(guardMap)(context, event, meta)\n    }\n    return values\n  }\n}\n", "import { ref, snapshot, subscribe, subscribeKey } from \"@zag-js/store\"\nimport {\n  cast,\n  clear,\n  compact,\n  invariant,\n  isArray,\n  isDev,\n  isObject,\n  isString,\n  noop,\n  runIfFn,\n  uuid,\n  warn,\n} from \"@zag-js/utils\"\nimport { createProxy } from \"./create-proxy\"\nimport { deepMerge } from \"./deep-merge\"\nimport { determineDelayFn } from \"./delay-utils\"\nimport { determineActionsFn, determineGuardFn } from \"./guard-utils\"\nimport { determineTransitionFn } from \"./transition-utils\"\nimport {\n  ActionTypes,\n  MachineStatus,\n  MachineType,\n  type Dict,\n  type StateMachine as S,\n  type VoidFunction,\n  type Writable,\n} from \"./types\"\nimport { structuredClone, toArray, toEvent } from \"./utils\"\n\nexport class Machine<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n> {\n  public status: MachineStatus = MachineStatus.NotStarted\n  public readonly state: S.State<TContext, TState, TEvent>\n\n  public initialState: S.StateInfo<TContext, TState, TEvent> | undefined\n  public initialContext: TContext\n\n  public id: string\n\n  public type: MachineType = MachineType.Machine\n\n  // Cleanup function map (per state)\n  private activityEvents = new Map<string, Set<VoidFunction>>()\n  private delayedEvents = new Map<string, VoidFunction[]>()\n\n  // state update listeners the user can opt-in for\n  private stateListeners = new Set<S.StateListener<TContext, TState, TEvent>>()\n  private contextListeners = new Set<S.ContextListener<TContext>>()\n  private eventListeners = new Set<S.EventListener<TEvent>>()\n  private doneListeners = new Set<S.StateListener<TContext, TState, TEvent>>()\n  private contextWatchers = new Set<VoidFunction>()\n\n  // Cleanup functions (for `subscribe`)\n  private removeStateListener: VoidFunction = noop\n  private removeEventListener: VoidFunction = noop\n  private removeContextListener: VoidFunction = noop\n\n  // For Parent <==> Spawned Actor relationship\n  private parent?: AnyMachine\n  private children = new Map<string, AnyMachine>()\n\n  // A map of guard, action, delay implementations\n  private guardMap: S.GuardMap<TContext, TState, TEvent>\n  private actionMap: S.ActionMap<TContext, TState, TEvent>\n  private delayMap: S.DelayMap<TContext, TEvent>\n  private activityMap: S.ActivityMap<TContext, TState, TEvent>\n  private sync: boolean\n  public options: S.MachineOptions<TContext, TState, TEvent>\n  public config: S.MachineConfig<TContext, TState, TEvent>\n\n  // Let's get started!\n  constructor(config: S.MachineConfig<TContext, TState, TEvent>, options?: S.MachineOptions<TContext, TState, TEvent>) {\n    // clone the config and options\n    this.config = structuredClone(config)\n    this.options = structuredClone(options ?? {})\n\n    this.id = this.config.id ?? `machine-${uuid()}`\n\n    // maps\n    this.guardMap = this.options?.guards ?? {}\n    this.actionMap = this.options?.actions ?? {}\n    this.delayMap = this.options?.delays ?? {}\n    this.activityMap = this.options?.activities ?? {}\n    this.sync = this.options?.sync ?? false\n\n    // create mutatable state\n    this.state = createProxy(this.config)\n    this.initialContext = snapshot(this.state.context)\n    this.transformContext(this.state.context)\n\n    // created actions\n    const event = toEvent<TEvent>(ActionTypes.Created)\n    this.executeActions(this.config?.created, event)\n  }\n\n  // immutable state value\n  private get stateSnapshot(): S.State<TContext, TState, TEvent> {\n    return cast(snapshot(this.state))\n  }\n\n  public getState(): S.State<TContext, TState, TEvent> {\n    return this.stateSnapshot\n  }\n\n  // immutable context value\n  private get contextSnapshot(): TContext {\n    return this.stateSnapshot.context\n  }\n\n  // Starts the interpreted machine.\n  public start = (init?: S.StateInit<TContext, TState>) => {\n    // reset state back to empty (for SSR, we had to set state.value to initial value)\n    this.state.value = \"\"\n\n    // Don't start if it's already running\n    if (this.status === MachineStatus.Running) {\n      return this\n    }\n\n    this.status = MachineStatus.Running\n\n    // subscribe to state changes\n    this.removeStateListener = subscribe(\n      this.state,\n      () => {\n        this.stateListeners.forEach((listener) => {\n          listener(this.stateSnapshot)\n        })\n      },\n      this.sync,\n    )\n\n    // subscribe to event changes\n    this.removeEventListener = subscribeKey(\n      this.state,\n      \"event\",\n      (event) => {\n        this.executeActions(this.config.onEvent, event)\n        this.eventListeners.forEach((listener) => {\n          listener(event)\n        })\n      },\n      this.sync,\n    )\n\n    // subscribe to context changes\n    this.removeContextListener = subscribe(\n      this.state.context,\n      () => {\n        this.log(\"Context:\", this.contextSnapshot)\n        this.contextListeners.forEach((listener) => {\n          listener(this.contextSnapshot)\n        })\n      },\n      this.sync || this.options.debug,\n    )\n\n    this.setupContextWatchers()\n\n    // execute initial actions and activities\n    this.executeActivities(toEvent<TEvent>(ActionTypes.Start), toArray(this.config.activities), ActionTypes.Start)\n    this.executeActions(this.config.entry, toEvent<TEvent>(ActionTypes.Start))\n\n    // start transition\n    const event = toEvent<TEvent>(ActionTypes.Init)\n\n    const target = isObject(init) ? init.value : init\n    const context = isObject(init) ? init.context : undefined\n\n    if (context) {\n      this.setContext(context as Partial<TContext>)\n    }\n\n    // start transition definition\n    const transition = {\n      target: target ?? this.config.initial,\n    }\n\n    const next = this.getNextStateInfo(transition, event)\n    this.initialState = next\n\n    this.performStateChangeEffects(this.state.value!, next, event)\n\n    return this\n  }\n\n  private setupContextWatchers = () => {\n    for (const [key, fn] of Object.entries(this.config.watch ?? {})) {\n      const compareFn = this.options.compareFns?.[key]\n      const cleanup = subscribeKey(\n        this.state.context,\n        key,\n        () => {\n          this.executeActions(fn, this.state.event as TEvent)\n        },\n        this.sync,\n        compareFn,\n      )\n      this.contextWatchers.add(cleanup)\n    }\n  }\n\n  // Stops the interpreted machine\n  stop = () => {\n    // No need to call if already stopped\n    if (this.status === MachineStatus.Stopped) return\n\n    // exit current state\n    this.performExitEffects(this.state.value!, toEvent<TEvent>(ActionTypes.Stop))\n\n    // execute root stop or exit actions\n    this.executeActions(this.config.exit, toEvent<TEvent>(ActionTypes.Stop))\n\n    this.setState(\"\")\n    this.setEvent(ActionTypes.Stop)\n\n    // cleanups\n    this.stopStateListeners()\n    this.stopChildren()\n    this.stopActivities()\n    this.stopDelayedEvents()\n    this.stopContextWatchers()\n    this.stopEventListeners()\n    this.stopContextListeners()\n\n    this.status = MachineStatus.Stopped\n    return this\n  }\n\n  private stopEventListeners = () => {\n    this.eventListeners.clear()\n    this.removeEventListener()\n  }\n\n  private stopContextListeners = () => {\n    this.contextListeners.clear()\n    this.removeContextListener()\n  }\n\n  private stopStateListeners = () => {\n    this.removeStateListener()\n    this.stateListeners.clear()\n  }\n\n  private stopContextWatchers = () => {\n    this.contextWatchers.forEach((fn) => fn())\n    this.contextWatchers.clear()\n  }\n\n  private stopDelayedEvents = () => {\n    this.delayedEvents.forEach((state) => {\n      state.forEach((stop) => stop())\n    })\n    this.delayedEvents.clear()\n  }\n\n  // Cleanup running activities (e.g `setInterval`, invoked callbacks, promises)\n  private stopActivities = (state?: TState[\"value\"]) => {\n    // stop activities for a state\n    if (state) {\n      this.activityEvents.get(state)?.forEach((stop) => stop())\n      this.activityEvents.get(state)?.clear()\n      this.activityEvents.delete(state)\n    } else {\n      // stop every running activity\n      this.activityEvents.forEach((state) => {\n        state.forEach((stop) => stop())\n        state.clear()\n      })\n      this.activityEvents.clear()\n    }\n  }\n\n  /**\n   * Function to send event to spawned child machine or actor\n   */\n  public sendChild = (evt: S.Event<S.AnyEventObject>, to: string | ((ctx: TContext) => string)) => {\n    const event = toEvent(evt)\n    const id = runIfFn(to, this.contextSnapshot)\n    const child = this.children.get(id)\n    if (!child) {\n      invariant(`[@zag-js/core] Cannot send '${event.type}' event to unknown child`)\n    }\n    child!.send(event)\n  }\n\n  /**\n   * Function to stop a running child machine or actor\n   */\n  public stopChild = (id: string) => {\n    if (!this.children.has(id)) {\n      invariant(`[@zag-js/core > stop-child] Cannot stop unknown child ${id}`)\n    }\n    this.children.get(id)!.stop()\n    this.children.delete(id)\n  }\n\n  public removeChild = (id: string) => {\n    this.children.delete(id)\n  }\n\n  // Stop and delete spawned actors\n  private stopChildren = () => {\n    this.children.forEach((child) => child.stop())\n    this.children.clear()\n  }\n\n  private setParent = (parent: any) => {\n    this.parent = parent\n  }\n\n  public spawn = <TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject = S.AnyEventObject>(\n    src: MachineSrc<TContext, TState, TEvent>,\n    id?: string,\n  ) => {\n    const actor = runIfFn(src)\n    if (id) actor.id = id\n    actor.type = MachineType.Actor\n    actor.setParent(this)\n    this.children.set(actor.id, cast(actor))\n\n    actor\n      .onDone(() => {\n        this.removeChild(actor.id)\n      })\n      .start()\n\n    return cast<typeof actor>(ref(actor))\n  }\n\n  private addActivityCleanup = (state: TState[\"value\"] | null, cleanup: VoidFunction) => {\n    if (!state) return\n    if (!this.activityEvents.has(state)) {\n      this.activityEvents.set(state, new Set([cleanup]))\n    } else {\n      this.activityEvents.get(state)?.add(cleanup)\n    }\n  }\n\n  private setState = (target: TState[\"value\"] | null) => {\n    this.state.previousValue = this.state.value\n    this.state.value = target\n\n    const stateNode = this.getStateNode(target)\n\n    if (target == null) {\n      // remove all tags\n      clear(this.state.tags)\n    } else {\n      this.state.tags = toArray(stateNode?.tags)\n    }\n  }\n\n  private transformContext = (context: Partial<Writable<TContext>> | Partial<TContext>) => {\n    this.options?.transformContext?.(context)\n    return context as TContext\n  }\n\n  /**\n   * To used within side effects for React or Vue to update context\n   */\n  public setContext = (context: Partial<Writable<TContext>> | undefined) => {\n    if (!context) return\n    deepMerge(this.state.context, this.transformContext(context))\n  }\n\n  public withContext = (context: Partial<Writable<TContext>>) => {\n    const transformed = this.transformContext(context)\n    const newContext = { ...this.config.context, ...compact(transformed) } as TContext\n    return new Machine({ ...this.config, context: newContext }, this.options)\n  }\n\n  public setOptions = (options: Partial<S.MachineOptions<TContext, TState, TEvent>>) => {\n    const opts = compact(options)\n    this.actionMap = { ...this.actionMap, ...opts.actions }\n    this.delayMap = { ...this.delayMap, ...opts.delays }\n    this.activityMap = { ...this.activityMap, ...opts.activities }\n    this.guardMap = { ...this.guardMap, ...opts.guards }\n  }\n\n  private getStateNode = (state: TState[\"value\"] | null) => {\n    if (!state) return\n    return this.config.states?.[state]\n  }\n\n  private getNextStateInfo = (\n    transitions: S.Transitions<TContext, TState, TEvent>,\n    event: TEvent,\n  ): S.StateInfo<TContext, TState, TEvent> => {\n    // pick transition\n    const transition = this.determineTransition(transitions, event)\n\n    const isTargetless = !transition?.target\n    const target = transition?.target ?? this.state.value\n    const changed = this.state.value !== target\n\n    const stateNode = this.getStateNode(target)\n    const reenter = !isTargetless && !changed && !transition?.internal\n\n    const info = {\n      reenter,\n      transition,\n      stateNode,\n      target: target!,\n      changed,\n    }\n\n    this.log(\"NextState:\", `[${event.type}]`, this.state.value, \"---->\", info.target)\n\n    return info\n  }\n\n  private getActionFromDelayedTransition = (transition: S.DelayedTransition<TContext, TState, TEvent>) => {\n    // get the computed delay\n    const event = toEvent<TEvent>(ActionTypes.After)\n\n    const determineDelay = determineDelayFn(transition.delay, this.delayMap)\n    const delay = determineDelay(this.contextSnapshot, event)\n\n    let id: ReturnType<typeof globalThis.setTimeout>\n\n    return {\n      entry: () => {\n        id = globalThis.setTimeout(() => {\n          const next = this.getNextStateInfo(transition, event)\n          this.performStateChangeEffects(this.state.value!, next, event)\n        }, delay)\n      },\n      exit: () => {\n        globalThis.clearTimeout(id)\n      },\n    }\n  }\n\n  /**\n   * All `after` events leverage `setTimeout` and `clearTimeout`,\n   * we invoke the `clearTimeout` on exit and `setTimeout` on entry.\n   *\n   * To achieve this, we split the `after` defintion into `entry` and `exit`\n   *  functions and append them to the state's `entry` and `exit` actions\n   */\n  private getDelayedEventActions = (state: TState[\"value\"]) => {\n    const stateNode = this.getStateNode(state)\n    const event = toEvent<TEvent>(ActionTypes.After)\n\n    if (!stateNode || !stateNode.after) return\n\n    const entries: VoidFunction[] = []\n    const exits: VoidFunction[] = []\n\n    if (isArray(stateNode.after)) {\n      //\n      const transition = this.determineTransition(stateNode.after, event)\n      if (!transition) return\n\n      const actions = this.getActionFromDelayedTransition(transition)\n      entries.push(actions.entry)\n      exits.push(actions.exit)\n      //\n    } else if (isObject(stateNode.after)) {\n      //\n      for (const delay in stateNode.after) {\n        const transition = stateNode.after[delay]\n        let resolvedTransition: S.DelayedTransition<TContext, TState, TEvent> = {}\n\n        if (isArray(transition)) {\n          //\n          const picked = this.determineTransition(transition, event)\n          if (picked) resolvedTransition = picked\n          //\n        } else if (isString(transition)) {\n          resolvedTransition = { target: transition, delay }\n        } else {\n          resolvedTransition = { ...transition, delay }\n        }\n\n        const actions = this.getActionFromDelayedTransition(resolvedTransition)\n\n        entries.push(actions.entry)\n        exits.push(actions.exit)\n      }\n    }\n\n    return { entries, exits }\n  }\n\n  /**\n   * A reference to the instance methods of the machine.\n   * Useful when spawning child machines and managing the communication between them.\n   */\n  private get self(): S.Self<TContext, TState, TEvent> {\n    const self = this\n    return {\n      id: this.id,\n      send: this.send.bind(this),\n      sendParent: this.sendParent.bind(this),\n      sendChild: this.sendChild.bind(this),\n      stop: this.stop.bind(this),\n      stopChild: this.stopChild.bind(this),\n      spawn: this.spawn.bind(this) as any,\n      get state() {\n        return self.stateSnapshot\n      },\n      get initialContext() {\n        return self.initialContext\n      },\n      get initialState() {\n        return self.initialState?.target ?? \"\"\n      },\n    }\n  }\n\n  private get meta(): S.Meta<TContext, TState, TEvent> {\n    return {\n      state: this.stateSnapshot,\n      guards: this.guardMap,\n      send: this.send.bind(this),\n      self: this.self,\n      initialContext: this.initialContext,\n      initialState: this.initialState?.target ?? \"\",\n      getState: () => this.stateSnapshot,\n      getAction: (key) => this.actionMap[key],\n      getGuard: (key) => this.guardMap[key],\n    }\n  }\n\n  private get guardMeta(): S.GuardMeta<TContext, TState, TEvent> {\n    return {\n      state: this.stateSnapshot,\n    }\n  }\n\n  /**\n   * Function to executes defined actions. It can accept actions as string\n   * (referencing `options.actions`) or actual functions.\n   */\n  private executeActions = (actions: S.Actions<TContext, TState, TEvent> | undefined, event: TEvent) => {\n    const pickedActions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event, this.guardMeta)\n    for (const action of toArray(pickedActions)) {\n      const fn = isString(action) ? this.actionMap?.[action] : action\n      warn(\n        isString(action) && !fn,\n        `[@zag-js/core > execute-actions] No implementation found for action: \\`${action}\\``,\n      )\n      fn?.(this.state.context, event, this.meta)\n    }\n  }\n\n  /**\n   * Function to execute running activities and registers\n   * their cleanup function internally (to be called later on when we exit the state)\n   */\n  private executeActivities = (\n    event: TEvent,\n    activities: Array<S.Activity<TContext, TState, TEvent>>,\n    state?: TState[\"value\"],\n  ) => {\n    for (const activity of activities) {\n      const fn = isString(activity) ? this.activityMap?.[activity] : activity\n\n      if (!fn) {\n        warn(`[@zag-js/core > execute-activity] No implementation found for activity: \\`${activity}\\``)\n        continue\n      }\n\n      const cleanup = fn(this.state.context, event, this.meta)\n\n      if (cleanup) {\n        this.addActivityCleanup(state ?? this.state.value, cleanup)\n      }\n    }\n  }\n\n  /**\n   * Normalizes the `every` definition to transition. `every` can be:\n   * - An array of possible actions to run (we need to pick the first match based on guard)\n   * - An object of intervals and actions\n   */\n  private createEveryActivities = (\n    every: S.StateNode<TContext, TState, TEvent>[\"every\"] | undefined,\n    callbackfn: (activity: S.Activity<TContext, TState, TEvent>) => void,\n  ) => {\n    if (!every) return\n    const event = toEvent<TEvent>(ActionTypes.Every)\n\n    // every: [{ interval: 2000, actions: [...], guard: \"isValid\" },  { interval: 1000, actions: [...] }]\n    if (isArray(every)) {\n      // picked = { interval: string | number | <ref>, actions: [...], guard: ... }\n      const picked = toArray(every).find((transition) => {\n        //\n        const delayOrFn = transition.delay\n        const determineDelay = determineDelayFn(delayOrFn, this.delayMap)\n        const delay = determineDelay(this.contextSnapshot, event)\n\n        const determineGuard = determineGuardFn(transition.guard, this.guardMap)\n        const guard = determineGuard(this.contextSnapshot, event, this.guardMeta)\n\n        return guard ?? delay != null\n      })\n\n      if (!picked) return\n\n      const determineDelay = determineDelayFn(picked.delay, this.delayMap)\n      const delay = determineDelay(this.contextSnapshot, event)\n\n      const activity = () => {\n        const id = globalThis.setInterval(() => {\n          this.executeActions(picked.actions, event)\n        }, delay)\n        return () => {\n          globalThis.clearInterval(id)\n        }\n      }\n      callbackfn(activity)\n      //\n    } else {\n      // every = { 1000: [fn, fn] }\n      for (const interval in every) {\n        const actions = every?.[interval]\n\n        // interval could be a `ref` not the actual interval value, let's determine the actual value\n        const determineDelay = determineDelayFn(interval, this.delayMap)\n        const delay = determineDelay(this.contextSnapshot, event)\n\n        // create the activity to run for each `every` reaction\n        const activity = () => {\n          const id = globalThis.setInterval(() => {\n            this.executeActions(actions, event)\n          }, delay)\n          return () => {\n            globalThis.clearInterval(id)\n          }\n        }\n        callbackfn(activity)\n      }\n    }\n  }\n\n  private setEvent = (event: TEvent | TEvent[\"type\"]) => {\n    this.state.previousEvent = this.state.event\n    this.state.event = ref(toEvent(event))\n  }\n\n  private performExitEffects = (current: TState[\"value\"] | undefined, event: TEvent) => {\n    const currentState = this.state.value!\n\n    // don't clean up root state, it'll get cleaned up on stop()\n    if (currentState === \"\") return\n\n    const stateNode = current ? this.getStateNode(current) : undefined\n\n    // cleanup activities for current state\n    this.stopActivities(currentState)\n\n    // get explicit exit and implicit \"after.exit\" actions for current state\n    const _exit = determineActionsFn(stateNode?.exit, this.guardMap)(this.contextSnapshot, event, this.guardMeta)\n    const exitActions = toArray(_exit)\n\n    const afterExitActions = this.delayedEvents.get(currentState)\n\n    if (afterExitActions) {\n      exitActions.push(...afterExitActions)\n    }\n\n    // call all exit actions for current state\n    this.executeActions(exitActions, event)\n\n    // remove all registered listeners\n    this.eventListeners.clear()\n  }\n\n  private performEntryEffects = (next: TState[\"value\"], event: TEvent) => {\n    const stateNode = this.getStateNode(next)\n\n    // execute activities for next state\n    const activities = toArray(stateNode?.activities)\n\n    // if `every` is defined, create an activity and append to activities\n    this.createEveryActivities(stateNode?.every, (activity) => {\n      activities.unshift(activity)\n    })\n\n    if (activities.length > 0) {\n      this.executeActivities(event, activities)\n    }\n\n    // get all entry actions\n    const pickedActions = determineActionsFn(stateNode?.entry, this.guardMap)(\n      this.contextSnapshot,\n      event,\n      this.guardMeta,\n    )\n    const entryActions = toArray(pickedActions)\n    const afterActions = this.getDelayedEventActions(next)\n\n    if (stateNode?.after && afterActions) {\n      this.delayedEvents.set(next, afterActions?.exits)\n      entryActions.push(...afterActions.entries)\n    }\n\n    // execute entry actions for next state\n    this.executeActions(entryActions, event)\n\n    if (stateNode?.type === \"final\") {\n      this.state.done = true\n      this.doneListeners.forEach((listener) => {\n        listener(this.stateSnapshot)\n      })\n      this.stop()\n    }\n  }\n\n  private performTransitionEffects = (\n    transitions: S.Transitions<TContext, TState, TEvent> | undefined,\n    event: TEvent,\n  ) => {\n    // execute transition actions\n    const transition = this.determineTransition(transitions, event)\n    this.executeActions(transition?.actions, event)\n  }\n\n  /**\n   * Performs all the requires side-effects or reactions when\n   * we move from state A => state B.\n   *\n   * The Effect order:\n   * Exit actions (current state) => Transition actions  => Go to state => Entry actions (next state)\n   */\n  private performStateChangeEffects = (\n    current: TState[\"value\"] | undefined,\n    next: S.StateInfo<TContext, TState, TEvent>,\n    event: TEvent,\n  ) => {\n    // update event\n    this.setEvent(event)\n\n    const changed = next.changed || next.reenter\n\n    if (changed) {\n      this.performExitEffects(current, event)\n    }\n\n    // execute transition actions\n    this.performTransitionEffects(next.transition, event)\n\n    // go to next state\n    this.setState(next.target)\n\n    if (changed) {\n      this.performEntryEffects(next.target, event)\n    }\n  }\n\n  private determineTransition = (transition: S.Transitions<TContext, TState, TEvent> | undefined, event: TEvent) => {\n    const fn = determineTransitionFn(transition, this.guardMap)\n    return fn?.(this.contextSnapshot, event, this.guardMeta)\n  }\n\n  /**\n   * Function to send event to parent machine from spawned child\n   */\n  public sendParent = (evt: S.Event<S.AnyEventObject>) => {\n    if (!this.parent) {\n      invariant(\"[@zag-js/core > send-parent] Cannot send event to an unknown parent\")\n    }\n    const event = toEvent<S.AnyEventObject>(evt)\n    this.parent?.send(event)\n  }\n\n  private log = (...args: any[]) => {\n    if (isDev() && this.options.debug) {\n      console.log(...args)\n    }\n  }\n\n  /**\n   * Function to send an event to current machine\n   */\n  public send = (evt: S.Event<TEvent>) => {\n    const event = toEvent<TEvent>(evt)\n    this.transition(this.state.value, event)\n  }\n\n  public transition = (state: TState[\"value\"] | S.StateInfo<TContext, TState, TEvent> | null, evt: S.Event<TEvent>) => {\n    const stateNode = isString(state) ? this.getStateNode(state) : state?.stateNode\n\n    const event = toEvent(evt)\n\n    if (!stateNode && !this.config.on) {\n      const msg =\n        this.status === MachineStatus.Stopped\n          ? \"[@zag-js/core > transition] Cannot transition a stopped machine\"\n          : `[@zag-js/core > transition] State does not have a definition for \\`state\\`: ${state}, \\`event\\`: ${event.type}`\n      warn(msg)\n      return\n    }\n\n    const transitions: S.Transitions<TContext, TState, TEvent> =\n      stateNode?.on?.[event.type] ?? this.config.on?.[event.type]\n\n    const next = this.getNextStateInfo(transitions, event)\n    this.performStateChangeEffects(this.state.value!, next, event)\n\n    return next.stateNode\n  }\n\n  subscribe = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.stateListeners.add(listener)\n\n    if (this.status === MachineStatus.Running) {\n      listener(this.stateSnapshot)\n    }\n\n    return () => {\n      this.stateListeners.delete(listener)\n    }\n  }\n\n  public onDone = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.doneListeners.add(listener)\n    return this\n  }\n\n  public onTransition = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.stateListeners.add(listener)\n    if (this.status === MachineStatus.Running) {\n      listener(this.stateSnapshot)\n    }\n    return this\n  }\n\n  public onChange = (listener: S.ContextListener<TContext>) => {\n    this.contextListeners.add(listener)\n    return this\n  }\n\n  public onEvent = (listener: S.EventListener<TEvent>) => {\n    this.eventListeners.add(listener)\n    return this\n  }\n\n  get [Symbol.toStringTag]() {\n    return \"Machine\"\n  }\n}\n\nexport type MachineSrc<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n> = Machine<TContext, TState, TEvent> | (() => Machine<TContext, TState, TEvent>)\n\nexport type AnyMachine = Machine<Dict, S.StateSchema, S.AnyEventObject>\n\nexport const createMachine = <\n  TContext extends Dict,\n  TState extends S.StateSchema = S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n>(\n  config: S.MachineConfig<TContext, TState, TEvent>,\n  options?: S.MachineOptions<TContext, TState, TEvent>,\n) => new Machine(config, options)\n", "import { proxy, proxyWithComputed } from \"@zag-js/store\"\nimport { cast } from \"@zag-js/utils\"\nimport { ActionTypes, type Dict, type StateMachine as S } from \"./types\"\n\nexport function createProxy<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  config: S.MachineConfig<TContext, TState, TEvent>,\n) {\n  const computedContext: Dict = config.computed ?? cast<S.TComputedContext<TContext>>({})\n  const initialContext = config.context ?? cast<TContext>({})\n\n  const state = proxy({\n    value: config.initial ?? \"\",\n    previousValue: \"\",\n    event: cast<Dict>({}),\n    previousEvent: cast<Dict>({}),\n    context: proxyWithComputed(initialContext, computedContext),\n    done: false,\n    tags: [] as Array<TState[\"tags\"]>,\n    hasTag(tag: TState[\"tags\"]): boolean {\n      return this.tags.includes(tag)\n    },\n    matches(...value: string[]): boolean {\n      return value.includes(this.value)\n    },\n    can(event: string): boolean {\n      return cast<any>(this).nextEvents.includes(event)\n    },\n    get nextEvents() {\n      const stateEvents = (config.states as Dict)?.[this.value]?.[\"on\"] ?? {}\n      const globalEvents = config?.on ?? {}\n      return Object.keys({ ...stateEvents, ...globalEvents })\n    },\n    get changed() {\n      if (this.event.value === ActionTypes.Init || !this.previousValue) return false\n      return this.value !== this.previousValue\n    },\n  })\n\n  return cast<S.State<TContext, TState, TEvent>>(state)\n}\n", "import { invariant, isFunction, isNumber, isString } from \"@zag-js/utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\n\n/**\n * Delay can be specified as:\n * - a string (reference to `options.delays`)\n * - a number (in ms)\n * - a function that returns a number (in ms)\n *\n * Let's resolve this to a number\n */\nexport function determineDelayFn<TContext extends Dict, TEvent extends S.EventObject>(\n  delay: S.Delay<TContext, TEvent> | undefined,\n  delaysMap: S.DelayMap<TContext, TEvent> | undefined,\n) {\n  return (context: TContext, event: TEvent) => {\n    if (isNumber(delay)) return delay\n\n    if (isFunction(delay)) {\n      return delay(context, event)\n    }\n\n    if (isString(delay)) {\n      const value = Number.parseFloat(delay)\n\n      if (!Number.isNaN(value)) {\n        return value\n      }\n\n      if (delaysMap) {\n        const valueOrFn = delaysMap?.[delay]\n\n        invariant(\n          valueOrFn == null,\n          `[@zag-js/core > determine-delay] Cannot determine delay for \\`${delay}\\`. It doesn't exist in \\`options.delays\\``,\n        )\n\n        return isFunction(valueOrFn) ? valueOrFn(context, event) : valueOrFn\n      }\n    }\n  }\n}\n", "import { isString } from \"@zag-js/utils\"\nimport { determineGuardFn } from \"./guard-utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\nimport { toArray } from \"./utils\"\n\n/**\n * A transition is an object that describes the next state, or/and actions\n * that should run when an event is sent.\n *\n * Transitions can be specified as:\n * - A single string: \"spinning\"\n * - An object with `target`, `actions`, or `guard`: { target: \"spinning\", actions: [...], guard: isValid }\n * - An array of possible transitions. In this case, we'll pick the first matching transition\n * depending on the `guard` specified\n */\n\nexport function toTarget<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  target: S.Transition<TContext, TState, TEvent>,\n): S.TransitionDefinition<TContext, TState, TEvent> {\n  return isString(target) ? { target } : target\n}\n\nexport function determineTransitionFn<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject,\n>(transitions: S.Transitions<TContext, TState, TEvent> | undefined, guardMap: S.GuardMap<TContext, TState, TEvent>) {\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    return toArray(transitions)\n      .map(toTarget)\n      .find((transition) => {\n        // get condition function\n        const determineGuard = determineGuardFn(transition.guard, guardMap)\n        const guard = determineGuard(context, event, meta)\n        return guard ?? transition.target ?? transition.actions\n      })\n  }\n}\n", "import { callAll } from \"@zag-js/utils\"\n\ninterface Props {\n  [key: string]: any\n}\n\nconst clsx = (...args: (string | undefined)[]) =>\n  args\n    .map((str) => str?.trim())\n    .filter(Boolean)\n    .join(\" \")\n\ntype TupleTypes<T extends any[]> = T[number]\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never\n\nconst eventRegex = /^on[A-Z]/\n\nexport function mergeProps<T extends Props>(...args: T[]): UnionToIntersection<TupleTypes<T[]>> {\n  let result: Props = {}\n\n  for (let props of args) {\n    for (let key in result) {\n      if (eventRegex.test(key) && typeof result[key] === \"function\" && typeof props[key] === \"function\") {\n        result[key] = callAll(result[key], props[key])\n        continue\n      }\n\n      if (key === \"className\" || key === \"class\") {\n        result[key] = clsx(result[key], props[key])\n        continue\n      }\n\n      if (key === \"style\") {\n        result[key] = Object.assign({}, result[key] ?? {}, props[key] ?? {})\n        continue\n      }\n\n      result[key] = props[key] !== undefined ? props[key] : result[key]\n    }\n\n    // Add props from b that are not in a\n    for (let key in props) {\n      if (result[key] === undefined) {\n        result[key] = props[key]\n      }\n    }\n  }\n\n  return result as any\n}\n", "export type ElementSize = {\n  width: number\n  height: number\n}\n\nexport type ElementSizeCallback = (size: ElementSize | undefined) => void\n\nexport function trackElementSize(element: HTMLElement | null, callback: ElementSizeCallback) {\n  if (!element) {\n    callback(undefined)\n    return\n  }\n\n  callback({ width: element.offsetWidth, height: element.offsetHeight })\n\n  const win = element.ownerDocument.defaultView ?? window\n\n  const observer = new win.ResizeObserver((entries) => {\n    if (!Array.isArray(entries) || !entries.length) return\n\n    const [entry] = entries\n    let width: number\n    let height: number\n\n    if (\"borderBoxSize\" in entry) {\n      const borderSizeEntry = entry[\"borderBoxSize\"]\n      const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry\n      width = borderSize[\"inlineSize\"]\n      height = borderSize[\"blockSize\"]\n    } else {\n      width = element.offsetWidth\n      height = element.offsetHeight\n    }\n\n    callback({ width, height })\n  })\n\n  observer.observe(element, { box: \"border-box\" })\n\n  return () => observer.unobserve(element)\n}\n", "import { trackElementSize, type ElementSize } from \"./track-size\"\n\nexport type TrackElementsSizeOptions<T extends HTMLElement | null> = {\n  getNodes: () => T[]\n  observeMutation?: boolean\n  callback: (size: ElementSize | undefined, index: number) => void\n}\n\nexport function trackElementsSize<T extends HTMLElement | null>(options: TrackElementsSizeOptions<T>) {\n  const { getNodes, observeMutation = true, callback } = options\n\n  const cleanups: Array<VoidFunction | undefined> = []\n\n  let firstNode: T | null = null\n\n  function trigger() {\n    const elements = getNodes()\n    firstNode = elements[0]\n    const fns = elements.map((element, index) =>\n      trackElementSize(element, (size) => {\n        callback(size, index)\n      }),\n    )\n    cleanups.push(...fns)\n  }\n\n  trigger()\n\n  if (observeMutation) {\n    const fn = trackMutation(firstNode, trigger)\n    cleanups.push(fn)\n  }\n\n  return () => {\n    cleanups.forEach((cleanup) => {\n      cleanup?.()\n    })\n  }\n}\n\nfunction trackMutation(el: HTMLElement | null, cb: () => void) {\n  if (!el || !el.parentElement) return\n  const win = el.ownerDocument?.defaultView ?? window\n  const observer = new win.MutationObserver(() => {\n    cb()\n  })\n  observer.observe(el.parentElement, { childList: true })\n  return () => {\n    observer.disconnect()\n  }\n}\n", "export function toArray<T>(v: T | T[] | undefined | null): T[] {\n  if (!v) return []\n  return Array.isArray(v) ? v : [v]\n}\n\nexport const fromLength = (length: number) => Array.from(Array(length).keys())\n\nexport const first = <T>(v: T[]): T | undefined => v[0]\n\nexport const last = <T>(v: T[]): T | undefined => v[v.length - 1]\n\nexport const isEmpty = <T>(v: T[]): boolean => v.length === 0\n\nexport const has = <T>(v: T[], t: any): boolean => v.indexOf(t) !== -1\n\nexport const add = <T>(v: T[], ...items: T[]): T[] => v.concat(items)\n\nexport const remove = <T>(v: T[], item: T): T[] => removeAt(v, v.indexOf(item))\n\nexport const removeAt = <T>(v: T[], i: number): T[] => {\n  if (i > -1) v.splice(i, 1)\n  return v\n}\n\nexport function clear<T>(v: T[]): T[] {\n  while (v.length > 0) v.pop()\n  return v\n}\n\nexport type IndexOptions = {\n  step?: number\n  loop?: boolean\n}\n\nexport function nextIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  const next = idx + step\n  const len = v.length\n  const last = len - 1\n  if (idx === -1) return step > 0 ? 0 : last\n  if (next < 0) return loop ? last : 0\n  if (next >= len) return loop ? 0 : idx > len ? len : idx\n  return next\n}\n\nexport function next<T>(v: T[], idx: number, opts: IndexOptions = {}): T | undefined {\n  return v[nextIndex(v, idx, opts)]\n}\n\nexport function prevIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  return nextIndex(v, idx, { step: -step, loop })\n}\n\nexport function prev<T>(v: T[], index: number, opts: IndexOptions = {}): T | undefined {\n  return v[prevIndex(v, index, opts)]\n}\n\nexport const chunk = <T>(v: T[], size: number): T[][] => {\n  const res: T[][] = []\n  return v.reduce((rows, value, index) => {\n    if (index % size === 0) rows.push([value])\n    else last(rows)?.push(value)\n    return rows\n  }, res)\n}\n", "export const runIfFn = <T>(\n  v: T | undefined,\n  ...a: T extends (...a: any[]) => void ? Parameters<T> : never\n): T extends (...a: any[]) => void ? NonNullable<ReturnType<T>> : NonNullable<T> => {\n  const res = typeof v === \"function\" ? v(...a) : v\n  return res ?? undefined\n}\n\nexport const cast = <T>(v: unknown): T => v as T\n\nexport const noop = () => {}\n\nexport const callAll =\n  <T extends (...a: any[]) => void>(...fns: (T | undefined)[]) =>\n  (...a: Parameters<T>) => {\n    fns.forEach(function (fn) {\n      fn?.(...a)\n    })\n  }\n\nexport const uuid = /*#__PURE__*/ (() => {\n  let id = 0\n  return () => {\n    id++\n    return id.toString(36)\n  }\n})()\n", "export const isDev = () => process.env.NODE_ENV !== \"production\"\nexport const isArray = (v: any): v is any[] => Array.isArray(v)\nexport const isBoolean = (v: any): v is boolean => v === true || v === false\nexport const isObject = (v: any): v is Record<string, any> => !(v == null || typeof v !== \"object\" || isArray(v))\nexport const isNumber = (v: any): v is number => typeof v === \"number\" && !Number.isNaN(v)\nexport const isString = (v: any): v is string => typeof v === \"string\"\nexport const isFunction = (v: any): v is Function => typeof v === \"function\"\n\nexport const hasProp = <T extends string>(obj: any, prop: T): obj is Record<T, any> =>\n  Object.prototype.hasOwnProperty.call(obj, prop)\n", "export function compact<T extends Record<string, unknown> | undefined>(obj: T): T {\n  if (!isPlainObject(obj) || obj === undefined) {\n    return obj\n  }\n\n  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === \"string\")\n  const filtered: Partial<T> = {}\n  for (const key of keys) {\n    const value = (obj as any)[key]\n    if (value !== undefined) {\n      filtered[key as keyof T] = compact(value)\n    }\n  }\n  return filtered as T\n}\n\nexport function json(value: any) {\n  return JSON.parse(JSON.stringify(value))\n}\n\nconst isPlainObject = (value: any) => {\n  return value && typeof value === \"object\" && value.constructor === Object\n}\n", "export function warn(m: string): void\nexport function warn(c: boolean, m: string): void\nexport function warn(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    console.warn(m)\n  }\n}\n\nexport function invariant(m: string): void\nexport function invariant(c: boolean, m: string): void\nexport function invariant(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    throw new Error(m)\n  }\n}\n", "import { createAnatomy } from \"@zag-js/anatomy\"\n\nexport const anatomy = createAnatomy(\"slider\").parts(\n  \"root\",\n  \"label\",\n  \"thumb\",\n  \"output\",\n  \"track\",\n  \"range\",\n  \"control\",\n  \"markerGroup\",\n  \"marker\",\n)\nexport const parts = anatomy.build()\n", "import {\n  getEventKey,\n  getEventPoint,\n  getEventStep,\n  getNativeEvent,\n  isLeftClick,\n  isModifiedEvent,\n  type EventKeyMap,\n} from \"@zag-js/dom-event\"\nimport { ariaAttr, dataAttr } from \"@zag-js/dom-query\"\nimport { getPercentValue, getValuePercent } from \"@zag-js/numeric-range\"\nimport type { NormalizeProps, PropTypes } from \"@zag-js/types\"\nimport { parts } from \"./slider.anatomy\"\nimport { dom } from \"./slider.dom\"\nimport type { PublicApi, Send, State } from \"./slider.types\"\n\nexport function connect<T extends PropTypes>(state: State, send: Send, normalize: NormalizeProps<T>): PublicApi<T> {\n  const ariaLabel = state.context[\"aria-label\"]\n  const ariaLabelledBy = state.context[\"aria-labelledby\"]\n  const ariaValueText = state.context.getAriaValueText?.(state.context.value)\n\n  const isFocused = state.matches(\"focus\")\n  const isDragging = state.matches(\"dragging\")\n  const isDisabled = state.context.disabled\n  const isInteractive = state.context.isInteractive\n  const isInvalid = state.context.invalid\n\n  function getPercentValueFn(percent: number) {\n    return getPercentValue(percent, state.context.min, state.context.max, state.context.step)\n  }\n\n  function getValuePercentFn(value: number) {\n    return getValuePercent(value, state.context.min, state.context.max)\n  }\n\n  // TODO - getMarkerState\n\n  return {\n    isFocused,\n    isDragging,\n    value: state.context.value,\n    percent: getValuePercent(state.context.value, state.context.min, state.context.max),\n\n    setValue(value: number) {\n      send({ type: \"SET_VALUE\", value })\n    },\n\n    getPercentValue: getPercentValueFn,\n\n    getValuePercent: getValuePercentFn,\n\n    focus() {\n      dom.getThumbEl(state.context)?.focus()\n    },\n    /**\n     * Function to increment the value of the slider by the step.\n     */\n    increment() {\n      send(\"INCREMENT\")\n    },\n\n    decrement() {\n      send(\"DECREMENT\")\n    },\n\n    rootProps: normalize.element({\n      ...parts.root.attrs,\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-focus\": dataAttr(isFocused),\n      \"data-orientation\": state.context.orientation,\n      \"data-invalid\": dataAttr(isInvalid),\n      id: dom.getRootId(state.context),\n      dir: state.context.dir,\n      style: dom.getRootStyle(state.context),\n    }),\n\n    labelProps: normalize.label({\n      ...parts.label.attrs,\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-invalid\": dataAttr(isInvalid),\n      \"data-focus\": dataAttr(isFocused),\n      id: dom.getLabelId(state.context),\n      htmlFor: dom.getHiddenInputId(state.context),\n      onClick(event) {\n        if (!isInteractive) return\n        event.preventDefault()\n        dom.getThumbEl(state.context)?.focus()\n      },\n      style: dom.getLabelStyle(),\n    }),\n\n    thumbProps: normalize.element({\n      ...parts.thumb.attrs,\n      id: dom.getThumbId(state.context),\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-orientation\": state.context.orientation,\n      \"data-focus\": dataAttr(isFocused),\n      draggable: false,\n      \"aria-invalid\": ariaAttr(isInvalid),\n      \"data-invalid\": dataAttr(isInvalid),\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabel ? undefined : ariaLabelledBy ?? dom.getLabelId(state.context),\n      \"aria-orientation\": state.context.orientation,\n      \"aria-valuemax\": state.context.max,\n      \"aria-valuemin\": state.context.min,\n      \"aria-valuenow\": state.context.value,\n      \"aria-valuetext\": ariaValueText,\n      role: \"slider\",\n      tabIndex: isDisabled ? undefined : 0,\n      onBlur() {\n        if (!isInteractive) return\n        send(\"BLUR\")\n      },\n      onFocus() {\n        if (!isInteractive) return\n        send(\"FOCUS\")\n      },\n      onKeyDown(event) {\n        if (!isInteractive) return\n        const step = getEventStep(event) * state.context.step\n        let prevent = true\n        const keyMap: EventKeyMap = {\n          ArrowUp() {\n            send({ type: \"ARROW_UP\", step })\n            prevent = state.context.isVertical\n          },\n          ArrowDown() {\n            send({ type: \"ARROW_DOWN\", step })\n            prevent = state.context.isVertical\n          },\n          ArrowLeft() {\n            send({ type: \"ARROW_LEFT\", step })\n            prevent = state.context.isHorizontal\n          },\n          ArrowRight() {\n            send({ type: \"ARROW_RIGHT\", step })\n            prevent = state.context.isHorizontal\n          },\n          PageUp() {\n            send({ type: \"PAGE_UP\", step })\n          },\n          PageDown() {\n            send({ type: \"PAGE_DOWN\", step })\n          },\n          Home() {\n            send(\"HOME\")\n          },\n          End() {\n            send(\"END\")\n          },\n        }\n\n        const key = getEventKey(event, state.context)\n        const exec = keyMap[key]\n\n        if (!exec) return\n        exec(event)\n\n        if (prevent) {\n          event.preventDefault()\n        }\n      },\n      style: dom.getThumbStyle(state.context),\n    }),\n\n    hiddenInputProps: normalize.input({\n      type: \"text\",\n      defaultValue: state.context.value,\n      name: state.context.name,\n      form: state.context.form,\n      id: dom.getHiddenInputId(state.context),\n      hidden: true,\n    }),\n\n    outputProps: normalize.output({\n      ...parts.output.attrs,\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-invalid\": dataAttr(isInvalid),\n      \"data-orientation\": state.context.orientation,\n      id: dom.getOutputId(state.context),\n      htmlFor: dom.getHiddenInputId(state.context),\n      \"aria-live\": \"off\",\n    }),\n\n    trackProps: normalize.element({\n      ...parts.track.attrs,\n      id: dom.getTrackId(state.context),\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-focus\": dataAttr(isFocused),\n      \"data-invalid\": dataAttr(isInvalid),\n      \"data-orientation\": state.context.orientation,\n      style: dom.getTrackStyle(),\n    }),\n\n    rangeProps: normalize.element({\n      ...parts.range.attrs,\n      id: dom.getRangeId(state.context),\n      \"data-focus\": dataAttr(isFocused),\n      \"data-invalid\": dataAttr(isInvalid),\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-orientation\": state.context.orientation,\n      style: dom.getRangeStyle(state.context),\n    }),\n\n    controlProps: normalize.element({\n      ...parts.control.attrs,\n      id: dom.getControlId(state.context),\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-invalid\": dataAttr(isInvalid),\n      \"data-orientation\": state.context.orientation,\n      \"data-focus\": dataAttr(isFocused),\n      onPointerDown(event) {\n        if (!isInteractive) return\n\n        const evt = getNativeEvent(event)\n        if (!isLeftClick(evt) || isModifiedEvent(evt)) return\n\n        const point = getEventPoint(evt)\n        send({ type: \"POINTER_DOWN\", point })\n\n        event.preventDefault()\n        event.stopPropagation()\n      },\n      style: dom.getControlStyle(),\n    }),\n\n    markerGroupProps: normalize.element({\n      ...parts.markerGroup.attrs,\n      role: \"presentation\",\n      \"aria-hidden\": true,\n      \"data-orientation\": state.context.orientation,\n      style: dom.getMarkerGroupStyle(),\n    }),\n\n    getMarkerProps({ value }: { value: number }) {\n      const percent = getValuePercentFn(value)\n      const style = dom.getMarkerStyle(state.context, percent)\n      const markerState =\n        value > state.context.value ? \"over-value\" : value < state.context.value ? \"under-value\" : \"at-value\"\n\n      return normalize.element({\n        ...parts.marker.attrs,\n        id: dom.getMarkerId(state.context, value),\n        role: \"presentation\",\n        \"data-orientation\": state.context.orientation,\n        \"data-value\": value,\n        \"data-disabled\": dataAttr(isDisabled),\n        \"data-state\": markerState,\n        style,\n      })\n    },\n  }\n}\n", "import { getRelativePoint } from \"@zag-js/dom-event\"\nimport { createScope } from \"@zag-js/dom-query\"\nimport { dispatchInputValueEvent } from \"@zag-js/form-utils\"\nimport { getPercentValue } from \"@zag-js/numeric-range\"\nimport { styles } from \"./slider.style\"\nimport type { MachineContext as Ctx, Point } from \"./slider.types\"\n\nexport const dom = createScope({\n  ...styles,\n\n  getRootId: (ctx: Ctx) => ctx.ids?.root ?? `slider:${ctx.id}`,\n  getThumbId: (ctx: Ctx) => ctx.ids?.thumb ?? `slider:${ctx.id}:thumb`,\n  getControlId: (ctx: Ctx) => ctx.ids?.control ?? `slider:${ctx.id}:control`,\n  getHiddenInputId: (ctx: Ctx) => ctx.ids?.hiddenInput ?? `slider:${ctx.id}:input`,\n  getOutputId: (ctx: Ctx) => ctx.ids?.output ?? `slider:${ctx.id}:output`,\n  getTrackId: (ctx: Ctx) => ctx.ids?.track ?? `slider:${ctx.id}track`,\n  getRangeId: (ctx: Ctx) => ctx.ids?.track ?? `slider:${ctx.id}:range`,\n  getLabelId: (ctx: Ctx) => ctx.ids?.label ?? `slider:${ctx.id}:label`,\n  getMarkerId: (ctx: Ctx, value: number) => `slider:${ctx.id}:marker:${value}`,\n\n  getRootEl: (ctx: Ctx) => dom.getById(ctx, dom.getRootId(ctx)),\n  getThumbEl: (ctx: Ctx) => dom.getById(ctx, dom.getThumbId(ctx)),\n  getControlEl: (ctx: Ctx) => dom.getById(ctx, dom.getControlId(ctx)),\n  getHiddenInputEl: (ctx: Ctx) => dom.getById<HTMLInputElement>(ctx, dom.getHiddenInputId(ctx)),\n\n  getValueFromPoint(ctx: Ctx, point: Point): number | undefined {\n    const controlEl = dom.getControlEl(ctx)\n    if (!controlEl) return\n\n    const relativePoint = getRelativePoint(point, controlEl)\n    const percent = relativePoint.getPercentValue({\n      orientation: ctx.orientation,\n      dir: ctx.dir,\n      inverted: { y: true },\n    })\n    return getPercentValue(percent, ctx.min, ctx.max, ctx.step)\n  },\n\n  dispatchChangeEvent(ctx: Ctx) {\n    const input = dom.getHiddenInputEl(ctx)\n    if (!input) return\n    dispatchInputValueEvent(input, { value: ctx.value })\n  },\n})\n", "import { getValuePercent, getValueTransformer } from \"@zag-js/numeric-range\"\nimport type { Style } from \"@zag-js/types\"\nimport type { MachineContext as Ctx, SharedContext } from \"./slider.types\"\n\n/* -----------------------------------------------------------------------------\n * Thumb style calculations\n * -----------------------------------------------------------------------------*/\n\nfunction getVerticalThumbOffset(ctx: SharedContext) {\n  const { height = 0 } = ctx.thumbSize ?? {}\n  const getValue = getValueTransformer([ctx.min, ctx.max], [-height / 2, height / 2])\n  return parseFloat(getValue(ctx.value).toFixed(2))\n}\n\nfunction getHorizontalThumbOffset(ctx: SharedContext) {\n  const { width = 0 } = ctx.thumbSize ?? {}\n\n  if (ctx.isRtl) {\n    const getValue = getValueTransformer([ctx.max, ctx.min], [-width * 1.5, -width / 2])\n    return -1 * parseFloat(getValue(ctx.value).toFixed(2))\n  }\n\n  const getValue = getValueTransformer([ctx.min, ctx.max], [-width / 2, width / 2])\n  return parseFloat(getValue(ctx.value).toFixed(2))\n}\n\nfunction getThumbOffset(ctx: SharedContext) {\n  const percent = getValuePercent(ctx.value, ctx.min, ctx.max) * 100\n\n  if (ctx.thumbAlignment === \"center\") {\n    return `${percent}%`\n  }\n\n  const offset = ctx.isVertical ? getVerticalThumbOffset(ctx) : getHorizontalThumbOffset(ctx)\n  return `calc(${percent}% - ${offset}px)`\n}\n\nfunction getVisibility(ctx: SharedContext) {\n  let visibility: \"visible\" | \"hidden\" = \"visible\"\n  if (ctx.thumbAlignment === \"contain\" && !ctx.hasMeasuredThumbSize) {\n    visibility = \"hidden\"\n  }\n  return visibility\n}\n\nfunction getThumbStyle(ctx: SharedContext): Style {\n  const placementProp = ctx.isVertical ? \"bottom\" : ctx.isRtl ? \"right\" : \"left\"\n  return {\n    visibility: getVisibility(ctx),\n    position: \"absolute\",\n    transform: \"var(--slider-thumb-transform)\",\n    [placementProp]: \"var(--slider-thumb-offset)\",\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Range style calculations\n * -----------------------------------------------------------------------------*/\n\nfunction getRangeOffsets(ctx: Ctx) {\n  let start = \"0%\"\n  let end = `${100 - ctx.valuePercent}%`\n\n  if (ctx.origin === \"center\") {\n    const isNegative = ctx.valuePercent < 50\n    start = isNegative ? `${ctx.valuePercent}%` : \"50%\"\n    end = isNegative ? \"50%\" : end\n  }\n\n  return { start, end }\n}\n\nfunction getRangeStyle(ctx: Pick<SharedContext, \"isVertical\" | \"isRtl\">): Style {\n  if (ctx.isVertical) {\n    return {\n      position: \"absolute\",\n      bottom: \"var(--slider-range-start)\",\n      top: \"var(--slider-range-end)\",\n    }\n  }\n\n  return {\n    position: \"absolute\",\n    [ctx.isRtl ? \"right\" : \"left\"]: \"var(--slider-range-start)\",\n    [ctx.isRtl ? \"left\" : \"right\"]: \"var(--slider-range-end)\",\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Control style calculations\n * -----------------------------------------------------------------------------*/\n\nfunction getControlStyle(): Style {\n  return {\n    touchAction: \"none\",\n    userSelect: \"none\",\n    position: \"relative\",\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Root style calculations\n * -----------------------------------------------------------------------------*/\n\nfunction getRootStyle(ctx: Ctx): Style {\n  const range = getRangeOffsets(ctx)\n  return {\n    \"--slider-thumb-transform\": ctx.isVertical ? \"translateY(50%)\" : \"translateX(-50%)\",\n    \"--slider-thumb-offset\": getThumbOffset(ctx),\n    \"--slider-range-start\": range.start,\n    \"--slider-range-end\": range.end,\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Marker style calculations\n * -----------------------------------------------------------------------------*/\n\nfunction getMarkerStyle(ctx: Pick<SharedContext, \"isHorizontal\" | \"isRtl\">, percent: number): Style {\n  return {\n    position: \"absolute\",\n    pointerEvents: \"none\",\n    [ctx.isHorizontal ? \"left\" : \"bottom\"]: `${(ctx.isRtl ? 1 - percent : percent) * 100}%`,\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Label style calculations\n * -----------------------------------------------------------------------------*/\n\nfunction getLabelStyle(): Style {\n  return { userSelect: \"none\" }\n}\n\n/* -----------------------------------------------------------------------------\n * Label style calculations\n * -----------------------------------------------------------------------------*/\n\nfunction getTrackStyle(): Style {\n  return { position: \"relative\" }\n}\n\n/* -----------------------------------------------------------------------------\n * Label style calculations\n * -----------------------------------------------------------------------------*/\n\nfunction getMarkerGroupStyle(): Style {\n  return {\n    userSelect: \"none\",\n    pointerEvents: \"none\",\n    position: \"relative\",\n  }\n}\n\nexport const styles = {\n  getThumbOffset,\n  getControlStyle,\n  getThumbStyle,\n  getRangeStyle,\n  getRootStyle,\n  getMarkerStyle,\n  getLabelStyle,\n  getTrackStyle,\n  getMarkerGroupStyle,\n}\n", "import { createMachine } from \"@zag-js/core\"\nimport { trackPointerMove } from \"@zag-js/dom-event\"\nimport { raf } from \"@zag-js/dom-query\"\nimport { trackElementSize } from \"@zag-js/element-size\"\nimport { trackFormControl } from \"@zag-js/form-utils\"\nimport { clampValue, getValuePercent } from \"@zag-js/numeric-range\"\nimport { compact } from \"@zag-js/utils\"\nimport { dom } from \"./slider.dom\"\nimport type { MachineContext, MachineState, UserDefinedContext } from \"./slider.types\"\nimport { constrainValue, decrement, increment } from \"./slider.utils\"\n\nexport function machine(userContext: UserDefinedContext) {\n  const ctx = compact(userContext)\n  return createMachine<MachineContext, MachineState>(\n    {\n      id: \"slider\",\n      initial: \"idle\",\n      context: {\n        thumbSize: null,\n        thumbAlignment: \"contain\",\n        disabled: false,\n        threshold: 5,\n        dir: \"ltr\",\n        origin: \"start\",\n        orientation: \"horizontal\",\n        initialValue: null,\n        value: 0,\n        step: 1,\n        min: 0,\n        max: 100,\n        ...ctx,\n      },\n\n      computed: {\n        isHorizontal: (ctx) => ctx.orientation === \"horizontal\",\n        isVertical: (ctx) => ctx.orientation === \"vertical\",\n        isRtl: (ctx) => ctx.orientation === \"horizontal\" && ctx.dir === \"rtl\",\n        isInteractive: (ctx) => !(ctx.disabled || ctx.readOnly),\n        hasMeasuredThumbSize: (ctx) => ctx.thumbSize !== null,\n        valuePercent: (ctx) => 100 * getValuePercent(ctx.value, ctx.min, ctx.max),\n      },\n\n      watch: {\n        value: [\"invokeOnChange\", \"dispatchChangeEvent\"],\n      },\n\n      activities: [\"trackFormControlState\", \"trackThumbSize\"],\n\n      on: {\n        SET_VALUE: {\n          actions: \"setValue\",\n        },\n        INCREMENT: {\n          actions: \"increment\",\n        },\n        DECREMENT: {\n          actions: \"decrement\",\n        },\n      },\n\n      entry: [\"checkValue\"],\n\n      states: {\n        idle: {\n          on: {\n            POINTER_DOWN: {\n              target: \"dragging\",\n              actions: [\"setPointerValue\", \"invokeOnChangeStart\", \"focusThumb\"],\n            },\n            FOCUS: \"focus\",\n          },\n        },\n\n        focus: {\n          entry: \"focusThumb\",\n          on: {\n            POINTER_DOWN: {\n              target: \"dragging\",\n              actions: [\"setPointerValue\", \"invokeOnChangeStart\", \"focusThumb\"],\n            },\n            ARROW_LEFT: {\n              guard: \"isHorizontal\",\n              actions: \"decrement\",\n            },\n            ARROW_RIGHT: {\n              guard: \"isHorizontal\",\n              actions: \"increment\",\n            },\n            ARROW_UP: {\n              guard: \"isVertical\",\n              actions: \"increment\",\n            },\n            ARROW_DOWN: {\n              guard: \"isVertical\",\n              actions: \"decrement\",\n            },\n            PAGE_UP: {\n              actions: \"increment\",\n            },\n            PAGE_DOWN: {\n              actions: \"decrement\",\n            },\n            HOME: {\n              actions: \"setToMin\",\n            },\n            END: {\n              actions: \"setToMax\",\n            },\n            BLUR: \"idle\",\n          },\n        },\n\n        dragging: {\n          entry: \"focusThumb\",\n          activities: \"trackPointerMove\",\n          on: {\n            POINTER_UP: {\n              target: \"focus\",\n              actions: \"invokeOnChangeEnd\",\n            },\n            POINTER_MOVE: {\n              actions: \"setPointerValue\",\n            },\n          },\n        },\n      },\n    },\n    {\n      guards: {\n        isHorizontal: (ctx) => ctx.isHorizontal,\n        isVertical: (ctx) => ctx.isVertical,\n      },\n\n      activities: {\n        trackFormControlState(ctx) {\n          return trackFormControl(dom.getHiddenInputEl(ctx), {\n            onFieldsetDisabled() {\n              ctx.disabled = true\n            },\n            onFormReset() {\n              if (ctx.initialValue != null) {\n                ctx.value = ctx.initialValue\n              }\n            },\n          })\n        },\n\n        trackPointerMove(ctx, _evt, { send }) {\n          return trackPointerMove(dom.getDoc(ctx), {\n            onPointerMove(info) {\n              send({ type: \"POINTER_MOVE\", point: info.point })\n            },\n            onPointerUp() {\n              send(\"POINTER_UP\")\n            },\n          })\n        },\n        trackThumbSize(ctx, _evt) {\n          if (ctx.thumbAlignment !== \"contain\") return\n          return trackElementSize(dom.getThumbEl(ctx), (size) => {\n            if (size) ctx.thumbSize = size\n          })\n        },\n      },\n\n      actions: {\n        checkValue(ctx) {\n          const value = constrainValue(ctx, ctx.value)\n          ctx.value = value\n          ctx.initialValue = value\n        },\n        invokeOnChangeStart(ctx) {\n          ctx.onChangeStart?.({ value: ctx.value })\n        },\n        invokeOnChangeEnd(ctx) {\n          ctx.onChangeEnd?.({ value: ctx.value })\n        },\n        invokeOnChange(ctx) {\n          ctx.onChange?.({ value: ctx.value })\n        },\n        dispatchChangeEvent(ctx) {\n          dom.dispatchChangeEvent(ctx)\n        },\n        setPointerValue(ctx, evt) {\n          const value = dom.getValueFromPoint(ctx, evt.point)\n          if (value == null) return\n          ctx.value = clampValue(value, ctx.min, ctx.max)\n        },\n        focusThumb(ctx) {\n          raf(() => dom.getThumbEl(ctx)?.focus())\n        },\n        decrement(ctx, evt) {\n          ctx.value = decrement(ctx, evt.step)\n        },\n        increment(ctx, evt) {\n          ctx.value = increment(ctx, evt.step)\n        },\n        setToMin(ctx) {\n          ctx.value = ctx.min\n        },\n        setToMax(ctx) {\n          ctx.value = ctx.max\n        },\n        setValue(ctx, evt) {\n          ctx.value = constrainValue(ctx, evt.value)\n        },\n      },\n    },\n  )\n}\n", "import { clampValue, getNextStepValue, getPreviousStepValue, snapValueToStep } from \"@zag-js/numeric-range\"\nimport type { MachineContext as Ctx } from \"./slider.types\"\n\nexport function clampPercent(percent: number) {\n  return clampValue(percent, 0, 1)\n}\n\nexport function constrainValue(ctx: Ctx, value: number) {\n  const snapValue = snapValueToStep(value, ctx.min, ctx.max, ctx.step)\n  return clampValue(snapValue, ctx.min, ctx.max)\n}\n\nexport function decrement(ctx: Ctx, step?: number) {\n  const index = 0\n  const values = getPreviousStepValue(index, {\n    ...ctx,\n    step: step ?? ctx.step,\n    values: [ctx.value],\n  })\n  return values[index]\n}\n\nexport function increment(ctx: Ctx, step?: number) {\n  const index = 0\n  const values = getNextStepValue(index, {\n    ...ctx,\n    step: step ?? ctx.step,\n    values: [ctx.value],\n  })\n  return values[index]\n}\n"],
  "mappings": "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",
  "names": ["parts", "query", "state", "set", "raf", "fn", "e", "e", "e", "getPercentValue", "TRACK_MEMO_SYMBOL", "Symbol", "GET_ORIGINAL_SYMBOL", "getProto", "Object", "getPrototypeOf", "objectsToTrack", "WeakMap", "isObjectToTrack", "obj", "has", "get", "prototype", "Array", "getUntracked", "obj", "isObjectToTrack", "GET_ORIGINAL_SYMBOL", "markToTrack", "mark", "objectsToTrack", "set", "proxyFunction", "e", "set", "isDev", "isObject", "c", "state", "event", "isObject", "_a", "_b", "options", "determineDelay", "delay", "isDev", "uuid", "compact", "isPlainObject", "isPlainObject", "getValue", "state", "getPercentValue", "getValuePercent", "_a", "keyMap", "compact", "ctx", "clampValue"]
}
